







## 线程池

经典 [progschj/ThreadPool: A simple C++11 Thread Pool implementation](https://github.com/progschj/ThreadPool)。

更多参考 `C-C++实用库备查.md` 的 workspace、dpool、CThreadPool 等库。



## 内存分配器



关于内存分配器的选择相关参考：

- [内存分配器ptmalloc,jemalloc,tcmalloc调研与对比_jemalloc与tcmalloc那个好-CSDN博客](https://blog.csdn.net/Rong_Toa/article/details/110689404)。
- [C++编程：第三方内存管理库TCMalloc和Jemalloc的测试和分析_jemalloc tcmalloc-CSDN博客](https://blog.csdn.net/stallion5632/article/details/141232583)。
- [存优化总结:ptmalloc、tcmalloc和jemalloc - 知乎](https://zhuanlan.zhihu.com/p/497509956)。
- [linux - C++ memory allocation mechanism performance comparison (tcmalloc vs. jemalloc) - Stack Overflow](https://stackoverflow.com/questions/7852731/c-memory-allocation-mechanism-performance-comparison-tcmalloc-vs-jemalloc)。
- [c - Using tcmalloc/jemalloc with custom memory pool manager - Stack Overflow](https://stackoverflow.com/questions/16933103/using-tcmalloc-jemalloc-with-custom-memory-pool-manager/35925155)。
- [Small Datum: Battle of the Mallocators](https://smalldatum.blogspot.com/2025/04/battle-of-mallocators.html)。



总结，性能上 tcmalloc 和 jemalloc 难分伯仲，各有优势场景，但 tcmalloc 更通用，且 jemalloc 目前已经停止维护了。

tcmalloc 会增加内存占用 和 cpu 占用，tcmalloc 适合 动态变化线程的场景，jemalloc 适合静态线程数量场景，这些都需要酌情考虑。



tcmalloc 使用：

- 官方文档 [gperftools/docs/tcmalloc.adoc 在 master ·gperftools/gperftools](https://github.com/gperftools/gperftools/blob/master/docs/tcmalloc.adoc)。注意有一些可配置项用于调优。
- 安装和使用参考 `编程经验-规范, 调试、性能和内存检查工具集合` 的 `gperftools` 一节。

在 不需要 heap proflier 时候，直接链接 `libtcmalloc_minimal` 即可。



## 内存池



找一找高性能流行的开源库。



std::pmr 机制，可以对 std 内置容器 当作 内存池。

参考：

- [深入探索C++17：资源管理新机制与 std::pmr 命名空间, 详解 std::pmr::unordered_map 的应用 - 知乎](https://zhuanlan.zhihu.com/p/678584515)。
- [C++基础之内存管理_std::pmr-CSDN博客](https://blog.csdn.net/qqliang1314/article/details/142929943)。



> 在高性能 socket 服务里，通常会采取 **分层策略**：
>
> | 方案                | 优点                                   | 缺点                             | 适用场景                       |
> | :------------------ | :------------------------------------- | :------------------------------- | :----------------------------- |
> | 内存池              | 极低分配开销、无碎片问题、缓存友好     | 实现复杂、可能浪费内存、灵活性差 | **固定大小对象**、高频分配释放 |
> | tcmalloc / jemalloc | 通用性强、减少锁竞争、良好的多线程性能 | 相比内存池仍有开销、可能产生碎片 | 通用场景、**多种对象大小**     |
>
> 1. 固定大小 buffer / connection 对象 → 内存池管理
>    - 例如 4KB/8KB buffer，`std::pmr::monotonic_buffer_resource` 或 内存池 等。
> 2. 不规则大小的临时分配 → jemalloc / tcmalloc 管理
>    - 避免碎片、提升多线程扩展性。
> 3. 极大对象（>1MB） → 直接 `mmap` / 系统调用
>    - 避免长时间占用堆。



**大型高并发服务，内存池/对象池 + tcmalloc / jemalloc 混合，二者结合：前者 避免 频繁申请和释放内存，后者 保证 在真正申请和释放内存的时候高效。**

**因此 内存池 / 对象池 + tcmalloc / jemalloc 都需要！这些都属于基础设施。**



## 对象池



找一找高性能流行的开源库。

实现个 通用 对象池，也可用作对象容器。再添加功能：构造时候可配置：从 new 分配内存，从 上面的 内存池 索要内存。

目前可用 自己实现的 ToolBox/GeneralContainer（暂未开源）。



