https://www.bilibili.com/video/BV1rE411W7YL?p=1
服务器配置： 8CPU 16G服务器 每秒10万活跃并发量 每个数据100字节

注意代码是增量更新 即在上一个版本的基础上修改代码 每个版本都会有client和server


目录说明：
1. 课程总览
2.一步一步建立高性能服务器
    01.easyTcp_v1  可以跑通过
    02.1 easyTCP_v2 
                    2-01 ~ 2-07  建立基本的客户端与服务器通信，持续通信
    02.1.1 HelloSocket发送结构化的网络消息数据
                    2-08 ~ 2-09  发送结构化的网络消息数据
    02.1.2 HelloSocket网络报文的数据格式定义及使用
                    2-10 ~ 2-13  网络报文的数据格式定义及使用
    02.2 将多次收发报文数据升级为一次收发
                    2-14 ~ 2-15  将多次收发报文数据升级为一次收发
                    2-16         网络消息接收长度问题
    02.3 客户端升级为select网络模型
                    2-17 ~ 2-20  服务端升级为select处理多客户端
                    2-21         服务端select设置为非阻塞，处理更多业务
                    2-22 ~ 2-24  客户端升级为select网络模型
    02.4 为客户端添加线程
                    2-25         为客户端添加输入线程
                    2-26 ~ 2-38  客户端升级 跨平台支持 Win，Linux，MacOS6
    03.easyTcp调整代码结构      
                                  
                    2-39 ~ 2-42  客户端封装Client类，同时与多个服务端通信
                    2-43 ~ 2-46  验证客户端同时与多个不同的服务端通信
                    2-47 ~ 2-50  服务端封装server类，创建多个server服务
    

    04.HelloSocket-粘包
                    2-51 ~ 2-53  在内外网中验证和测试粘包原因
                    2-54 ~ 2-56  解决客户端粘包
                    2-57 ~ 2-60  解决服务端粘包
                    2-61 ~ 2-63  解决粘包测试
    05.1HelloSocket突破64和高精度计时器
                    2-64 ~ 2-65  突破Windows下select64限制
                    2-66 ~ 2-67  添加高精度计时器测量处理能力
    05.2.test_c10k_2000k
                    2-68         单线程selcet模型10000链接测试
    06.HelloThread（）
                    2-69         多线程与单线程网络程序架构简介
                    2-70 ~ 2-77  多线程知识点
    ？？ 
                    2-77 ~ 2-78  1万个链接每秒处理200万个数据包
                    2-80 ~ 2-81  多线程分组模拟高频并发数据
                    2-82         服务端单模式下性能瓶颈测试
                    2-83         经典设计模式-生产者与消费者模式                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                    2-84         服务端-分离新客户端连接与消息处理业务
                    2-85         服务端-为消息处理线程添加新客户端缓冲队列
                    2-86         服务端-建立消息处理线程
                    2-87         服务端-将新客户端分配给客户数量最少的消息线程
                    2-88         服务端-消息处理线程在无客户端时休息1毫秒
                    2-89         服务端-为消息处理线程添加每秒收包计数
                    2-90         服务端-事件通知，有客户端退出
                    2-91         服务端-测试退出事件
                    2-92         服务端-内存不足
                    2-93         客户端-提高发送频率 每秒发送10个消息包
                    2-94         1万连接每秒处理200万包验证测试
                    2-95 ~ 2-99  注解、补充、代码调整

3.一步一步建立高性能服务器
                    3-1          本章内容介绍-一步一步建立高性能服务器
    0.1.select模型接收数据性能瓶颈与优化
                    3-2 ~ 3-05   服务端-select模型接收数据性能瓶颈与优化
    02.SocketAPI极限测试recv_send
                    3-6          socketAPI极限测试-添加recv与send计数
    03.SocketAPI极限测试recv                
                    3-7          socketAPI极限测试-recv1单线程接收测试
                    3-8          socketAPI极限测试-recv2多线程接收测试
                    3-9          socketAPI极限测试-recv3阿里云服务器
    04.SocketAPI极限测试send
                    3-10 ~ 3-12  socketAPI极限测试-send
    05.HelloSocket-CellServer数据收发的性能瓶颈
                    3-13 ~ 3-15  CellServer数据收发的性能瓶颈
    
                    3-16         定时定量发送数据
                    3-17 ~ 3-18  添加发送缓冲区-定量发送
    
                    3-19 ~ 3-24  Server消息接收与发送分离
    内存管理
                    3-25 ~ 3-27  内存管理-内存池设计
                    3-28 ~ 3-41  内存池实现
                    3-42 ~ 3-50  内存管理-智能指针
                    3-51 ~ 3-58  内存管理-对象池
                    3-59         内存管理-总结

        
                    3-60         回退到无内存管理
                    3-61 ~ 3-62  跨系统测试
                    3-63 ~ 3-64  优化代码结构-修复发送BUG，减小收发缓冲
                    3-65         C++11新特性-function与lambda
                    3-66         使用function与lambda优化TaskServer
                    3-67 ~ 3-69  心跳检测
                    3-70 ~ 3-71  定时发送缓存数据
                    3-72 ~ 3-73  并发多线程Server安全退出问题分析
                    3-74         实现简单的信号等待机制来控制线程退出
                    3-75         封装简单的信号量来控制Sever的关闭
                    3-76         使用condition_variable实现更安全的信号量
                    3-77 ~ 3-78  优化线程控制-源码改为utf8+bom字符编码
    HelloSocket-Server2.0_select模型异步发送数据-utf8 bom字符编码               
                    3-79 ~ 3-83  Server2.0_select模型异步发送数据
                    3-84         select模型异步发送6_Linux与MacOS测试
                    3-85 ~ 3-85  Server2.1-分离消息缓冲区
                    3-89 ~ 3-91  Server2.1-添加运行日志记录
                    3-92         Server2.1-分离网络环境启动与关闭
                    3-93         Server2.1_Linux与MacOS测试

4.多平台下的客户端网络通信
 01.              对应课程：

                  对应知识点：
                    4-1          本章内容介绍-多平台下的客户端网络通信
                    4-2          为前后端建立通用代码库
    HelloSocket-前后端共享代码库-客户端升级为异步收发
                    4-3 ~ 4-04   客户端升级为异步收发数据
                    4-5          使用字节流传输数据预览
                    4-6 ~ 4-08   字节流-建立字节流
                    4-9          字节流-写入基础类型
                    4-10         字节流-写入数组与字符串
                    4-11         字节流-读取基础类型
                    4-12         字节流-读取数组和字符串
                    4-13         字节流-读写测试
                    4-14         字节流-分类收发消息流
                    4-15         字节流-使用消息流传输数据
                    4-16         字节流-有三段补充
    unity-连接服务器   
                    4-17         在Unity中使用我们的通信引擎
                    4-18 ~ 4-19  Unity_C++插件应用基础
                    4-20 ~ 4-23  Unity_封装插件_Windows
                    4-24         Unity_封装插件_连接服务器
                    4-25         Unity_C#自定义收发字节流数据
                    4-26         Unity_C#写入流-基础类型
                    4-27         Unity_C#写入流-数组与字符串
                    4-28         Unity_C#写入流-发送数据-使用测试
                    4-29         Unity_C#解析流-基础类型
                    4-30         Unity_C#解析流-数组与字符串
                    4-31         Unity_C#解析流-解析数据-收发测试
    流数据
                    4-32         Unity_使用C++插件收发字节流数据
                    4-33         Unity_C++插件导出字节流操作接口
                    4-34         Unity_C++插件写入流数据
                    4-35         Unity_C++插件解析流数据
                    4-36         Unity_MacOSX_使用我们的通信引擎
                    4-37         Unity_IOS_使用我们的通信引擎
                    4-38 ~ 4-40  Unity_Android_编译C++动态库1
                    4-41 ~ 4-41  Unity_Android_使用我们的通信引擎1
                    4-43         Unity_补充-释放流内存
    CppNet100-应用到cocos2d-x-cpp            
                    4-44         在cocos2d-x-cpp中使用我们的通信引擎
    CppNet100-应用到cocos2d-x-cpp
                    4-45         在cocos2d-x-lua中使用我们的通信引擎
                    4-46         lua交互-基础知识
                    4-47         lua交互-接收和返回字符串
                    4-48         clua交互-注册回调函数
                    4-49         lua交互-tolua
                    4-50         lua交互-NativeClient      
                    4-51 ~ 4-53  lua交互-导出Client接口
                    4-54 ~ 4-55  lua交互-导出Write接口
                    4-56         lua交互-导出Read接口
                    4-57         lua交互-导出Read接口2-收发验证
                    4-58         lua交互-封装Client-lua-class
                    4-59         lua交互-封装写入流-lua-class
                    4-60         lua交互-封装解析流-收发验证
