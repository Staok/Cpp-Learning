#include<iostream>
using namespace std;

/*
多态就是多种形态 

多态分为两类

静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名
动态多态: 派生类和虚函数实现运行时多态

通常在C++中所说的多态 是指动态多态

静态多态和动态多态区别：
静态多态的函数地址早绑定  -  编译阶段确定函数地址
动态多态的函数地址晚绑定  -  运行阶段确定函数地址

总结：
多态满足条件

1）有继承关系
2）子类重写父类中的虚函数

多态使用条件

父类指针或引用指向子类对象
重写：函数返回值类型  函数名 参数列表 完全一致称为重写
*/

//动物类
class Animal
{
public:
	//Speak函数就是虚函数
	//函数前面如果不加 virtual关键字，属于地址早绑定，在编译阶段就确定了函数的地址，不管传入什么样的子类对象，都会执行父类的方法
	//函数前面加上virtual关键字，变成虚函数，属于地址晚绑定，那么编译器在编译的时候就不能确定函数调用了，只有在执行的时候才确定是哪个子类
	virtual void speak()
	{
		cout << "动物在说话" << endl;
	}
};

//猫类
class Cat :public Animal
{
public:
	void speak()
	{
		cout << "小猫在说话" << endl;
	}
};

//狗类
class Dog :public Animal
{
public:

	void speak()
	{
		cout << "小狗在说话" << endl;
	}

};
//我们希望传入什么对象，那么就调用什么对象的函数
//如果函数地址在编译阶段就能确定，那么静态联编
//如果函数地址在运行阶段才能确定，就是动态联编
//如果想执行让猫说话，那么这个函数地址就不能提前绑定，需要在运行阶段进行绑定，也就是地址晚绑定
void DoSpeak(Animal & animal)
{
	animal.speak();
}


//多态满足条件： 
//1、有继承关系
//2、子类重写父类中的虚函数，子类中的virtual关键字可以写也可以不写，但是对于虚函数而言，父类中肯定要写virtual关键字
//函数的返回值类型，函数名 参数列表 完全相同才叫重写 
//多态使用：
//父类指针或引用指向子类对象

void test01()
{
	Cat cat;
	DoSpeak(cat);


	Dog dog;
	DoSpeak(dog);
}


int main() {

	test01();
	return 0;
}