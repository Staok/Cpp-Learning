# extern "C"

## About Author：


![](../img/wechat.jpg)

## 1. Compiler difference between C and C ++

In C + +, we often see extern "C" modifier function in the header file. What's the effect. Is a function defined in C language module for C + + link.

Although C + + is compatible with C, the symbols generated by function compilation in C + + files are different from those generated by C language.Because C + + supports function overloading, the symbols generated by C + + function compilation have the information of function parameter type, while C does not.


Take `int add(int a, int b)` for example. The C + + compiler generates the. O file, `add` becomes `add_int_int` and so on, while C would be like this `_add`, that is：For the same function, in C and C + +, the symbols generated after compilation are different.

This leads to a problem: if the function implemented in C + + is implemented in C language, an error will occur when compiling the link, indicating that the corresponding symbol cannot be found. At this time`extern "C"` works：Tell the linker to find its `_ C `language symbols such as `add` are not modified by C ++.

## 2.C ++ calls C functions

When referring to the header file of C, you need to add `extern "C"`

```c++
//add.h
#ifndef ADD_H
#define ADD_H
int add(int x,int y);
#endif

//add.c
#include "add.h"

int add(int x,int y) {
    return x+y;
}

//add.cpp
#include <iostream>
#include "add.h"
using namespace std;
int main() {
    add(2,3);
    return 0;
}
```

Compile：

```
//Generate add.o file
gcc -c add.c
```

Link：

```
g++ add.cpp add.o -o main
```

Without extern "C"：

```c++
> g++ add.cpp add.o -o main                                   
add.o：在函数‘main’中：
add.cpp:(.text+0x0): `main'被多次定义
/tmp/ccH65yQF.o:add.cpp:(.text+0x0)：第一次在此定义
/tmp/ccH65yQF.o：在函数‘main’中：
add.cpp:(.text+0xf)：对‘add(int, int)’未定义的引用
add.o：在函数‘main’中：
add.cpp:(.text+0xf)：对‘add(int, int)’未定义的引用
collect2: error: ld returned 1 exit status
```

With extern "C"：

`add.cpp`

```c++
#include <iostream>
using namespace std;
extern "C" {
    #include "add.h"
}
int main() {
    add(2,3);
    return 0;
}
```
When compiling, you must pay attention to generating intermediate files add.o through GCC


```
gcc -c add.c 
```

Compile：

```
g++ add.cpp add.o -o main
```

Code：

- [add.h](extern_c++/add.h)

- [add.c](extern_c++/add.c)

- [add.cpp](extern_c++/add.cpp)

## 2.Calling C++ function in C


`extern "C"` It is a syntax error in C, which needs to be put in the C + + header file.

```c
// add.h
#ifndef ADD_H
#define ADD_H
extern "C" {
    int add(int x,int y);
}
#endif

// add.cpp
#include "add.h"

int add(int x,int y) {
    return x+y;
}

// add.c
extern int add(int x,int y);
int main() {
    add(2,3);
    return 0;
}
```

Compile：

```c
g++ -c add.cpp
```

Link：

```
gcc add.c add.o -o main
```

Code：

- [add.h](extern_c/add.h)

- [add.c](extern_c/add.c)

- [add.cpp](extern_c/add.cpp)

In the header file of C language, the external function can only be specified as extern type. The declaration of extern "C" is not supported in C language. There will be compiler syntax error when the. C file contains extern "C". Therefore, the use of external "C" is all placed in CPP program related files or its header files.


The following forms are summarized:

（1）C + + calls C functions:

```c++
//xx.h
extern int add(...)

//xx.c
int add(){
    
}

//xx.cpp
extern "C" {
    #include "xx.h"
}
```

（2）C calls C + + functions

```c
//xx.h
extern "C"{
    int add();
}
//xx.cpp
int add(){
    
}
//xx.c
extern int add();
```

