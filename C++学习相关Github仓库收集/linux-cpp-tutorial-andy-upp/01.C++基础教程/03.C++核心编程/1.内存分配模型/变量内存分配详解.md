http://lishicongli.blog.163.com/blog/static/1468259020115154859706/

1. 变量名不占空间
变量只是用来标识一块内存区域，这块区域的值一般是可以更改的，这就是它“变”的由来，但是我们可以通过使用如const等一些修饰符号来限定这一内存区域的操作特性（通过限定变量的操作特性）。在机器代码中，是不需要变量名的，想想汇编语言，没有变量名，操作内存是用地址来直接操作的，还要控制区域大小（当然汇编语言已经有了简单的变量）。变量名其实是高级语言为方便程序员编写程序是操作内存而提供的一种机制，这样我们就不用去记诸如23456788这样的内存地址，而是直接使用变量名来访问内存中的数据。而编译器则会生成一个叫做“符号表”的数据结构来维护变量名和内存地址直接的对应关系。它会搜集变量名，比如我们定义了一个全局的int a;那么编译器会为程序预留4个字节（32位平台）的空间，比如起始地址23456788（长度为4），并把变量名“a”和地址88888888保存进符号表，这样程序中对a进行相关操作时，它就会根据符号表找到变量的真正的物理位置（23456788），进行相关操作。 在机器执行程序的时候，会把变量名替换为内存地址（和长度），而不存在任何名称。

2. 指针

对于一般的变量，比如int a=10；这个很好理解，变量名直接对应内存地址（23456788），23456788-2345678C这段内存的值是10。需要注意的是指针名、数组名、函数名。指针其实是一个特殊的变量，第一个特殊的地方是他的值是一个内存地址，第二个特殊的地方在于指针包含了2层对应关系，第一层是符号表中的指针变量对应一块内存地址（比如是33456788），第二次对应关系是这块内存的值（23456788）指向了另外一个内存块()， 比如int *b=&a，这样*b和a就指向同一块内存块，改变a（或者*b）都会影响到*b（a）。可能根据类型的不同，*b（23456788）的长度（sizeof(*b)）会不一样，但是b（33456788）的长度总是4（32位系统），因为b只是用来存储一个地址（23456788，类似于一个整型变量），你可以赋给b一个地址，比如b=&a，甚至你可以赋给他一个内存地址（int add=0x8048642, int *p=(int *)add），但是你不能赋给b一个一般的值，比如b=10或b=’c’或b=3.14159。


变量, 指针和内存 - Lishic - Theres always a way
数组名、函数名在符号表中分别存储数组的首地址和函数的入口地址

 

3. 指针和数组

在一个文件定义了数组，却在另外一个文件声明其为指针。代码如下：
/*File name: main.c*/
extern int* array; /*声明指针*/
int main(void)
{
array[0]=1; /*用指针访问数据*/
return 0;
}

/*File name: def.c*/
int array[5]={0}; /*定义的却是数组*/

(1)数组情形
char a[9]="abcdefgh";
...
c=a[i];
在编译期，会在符号表中创建这样一条记录:
name:a address:9980
要获取a[i]的值分两个步骤:
step 1:取得i的值并和9980相加
step 2:在内存地址(9980+i)处取其内容

(2)指针情形
char* p="abcdefgh";
...
c=p[i];
在编译期，会在符号表中创建这样一条记录:
name:p address:4624
要获取p[i]的值分三个步骤:
step 1:在内存地址4624处取其内容，比如说“5081”
step 2:取得i的值并和5081相加
step 3:在内存地址(5081+i)取其内容

在def.c中定义array是一个int型数组，在符号表中就会有把array和array[0]的地址关联起来。而在main.c中却把把array看作是一个int型指针，于是乎按照上面介绍的指针寻址方式，把符号表中array的地址(即&array[0])中的内容当作指针来寻址，这显然是不对的。

 

4. 常量指针和指针常量

const int *b=&a

const int 修饰*b，b指向一个const int（常量），这种情况下，我们不能改变*b（即a的值，23456788），因为他是一个const，但是我们可以改变b（33456788）的值，即指针b指向别的内存地址，

比如b=&c(正确)

但是不能*b=30（错误，修改常量）

int *const b=&a

const 修饰b，b是一个const，指向int型，这种情况，我们不能改变b（33456788）的值，因为他是一个const，但是我们可以修改*b（即a的值，23456788）的值。

比如*b=30(正确)

但是不能b=&c(错误，修改常量)

 

正如前面所说，指针涉及到两个内存地址，一个存放了另外一块内存的地址，另一个存放了实际的值。我们可以设定其中一个或者2个都是const类型，const int *const b=&a.

 

5. 内存分配方式

1).从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。它们所需要的空间大小可以明确计算出来，并且不会再改变，因此它们可以直接存放在可执行文件的特定的节里（而且包含初始化的值），程序运行时也是直接将这个节加载到特定的段中，不必在程序运行期间用额外的代码来产生这些变量。

2).在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，由编译器负责分配和释放空间，内存使用效率很高，但是分配的内存容量有限。

#include <stdio.h>
char *returnStr()
{
    char p[]="hello world!";
    return p;
}
int main()
{
    char *str=NULL;
    str=returnStr();
    printf("%s\n", str);
    
    return 0;
}

"hello world!"是一个字符串常量，存放在静态数据区，把一个字符串常量赋值给了一个局部变量(char []型数组)，该局部变量存放在栈中，这样就有两块内容一样的内存，也就是说“char p[]="hello world!";”这条语句让“hello world!”这个字符串在内存中有两份拷贝，一份在动态分配的栈中，另一份在静态存储区。当returnStr函数退出时，栈要清空，局部变量的内存也被清空了，这样函数returnStr返回的指针就是指向一块已经被清空的内存地址，所以打印出来的是乱码。如果把char p[]改成指针类型char *p，就能正确输出”hello world”，因为函数退出虽然清空了栈内存，但是没有清空静态数据区。

3).从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。

需要注意的是，malloc函数的实质体现在，它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。调用malloc函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。调用free函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。如果无法获得符合要求的内存块，malloc函数会返回NULL指针，因此在调用malloc动态申请内存块时，一定要进行返回值的判断。