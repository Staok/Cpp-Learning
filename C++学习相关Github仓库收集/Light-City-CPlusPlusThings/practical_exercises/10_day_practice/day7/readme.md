运算符重载是C++的一项强大功能。通过重载，可以扩展C++运算符的功能，使它们能够操作用户自定义的数据类型，增加程序代码的直观性和可读性。

本章主要介绍 类成员运算符重载与友元运算符重载,  二元运算符与一元运算符重载,  运算符++、--、[]、（）重载,  this指针与运算符重载及 流运算符<<和>>的重载

一、重载二元运算符

1、二元运算符的调用形式与解析

aa@bb    可解释成  aa.operator@(bb)
               或解释成 operator@(aa,bb)

如果两者都有定义,就按照重载解析

```c++
class X{
public:
	void operator+(int);
	X(int);
};
void operator+(X,X);
void operator+(X,double);
```
2、类运算符重载形式

（1）非静态成员运算符重载

以类成员形式重载的运算符参数比实际参数少一个，第1个参数是以this指针隐式传递的。 

```c++
class Complex{
		double real,image;
public:
		Complex operator+(Complex b){……}
......
};
```
（2） 友元运算符重载

如果将运算符函数作为类的友元重载，它需要的参数个数就与运算符实际需要的参数个数相同。比如，若用友元函数重载Complex类的加法运算符，则形式如下：

```c++
class Complex{
……
		friend Complex operator+(Complex a,Complex b);		//声明
//......
};

Complex  operator+(Complex a,Complex b){……}     		//定义
```

二、重载一元运算符 

1、一元运算符

一元运算符只需要一个运算参数，如取地址运算符（&）、负数（?）、自增加（++）等。

2、一元运算符常见调用形式为：

@a     或    a@ 		//隐式调用形式

a.operator@()                   	// 显式调用一元运算符@

其中的@代表一元运算符，a代表操作数。

@a代表前缀一元运算，如“++a”；

a@表示后缀运算，如“a++”。

3、@a将被C++解释为下面的形式之一

a.operator@()

operator@(a) 

4.一元运算符作为类成员函数重载时不需要参数，其形式如下：

```c++
class X{
……
		T operator@(){……};
}
```
T是运算符@的返回类型。从形式上看，作为类成员函数重载的一元运算符没有参数，但实际上它包含了一个隐含参数

即调用对象的this指针。

5.前自增(减)与后自增(减)

C++编译器可以通过在运算符函数参数表中是否插入关键字int 来区分这两种方式

```c++
//前缀
operator -- ();
operator -- (X & x);
//后缀
operator -- (int);
operator -- (X & x, int);
```
三、重载赋值运算符=

1、赋值运算符“=”的重载特殊性

赋值运算进行时将调用此运算符

只能用成员函数重载

如果需要而没有定义时，编译器自动生成，该版本进行bit-by-bit拷贝

四、重载赋值运算符[]

1、[ ]是一个二元运算符，其重载形式如下：

```c++
class X{
……
		X& operator[](int n);
};
```
2、重载[]需要注意的问题
- []是一个二元运算符，其第1个参数是通过对象的this指针传递的，第2个参数代表数组的下标
- 由于[]既可以出现在赋值符“=”的左边，也可以出现在赋值符“=”的右边，所以重载运算符[]时常返回引用。
- **[]只能被重载为类的非静态成员函数，不能被重载为友元和普通函数**。

五、重载( ) 

1、运算符( )是函数调用运算符，也能被重载。且只能被重载为类的成员函数。

2、运算符( )的重载形式如下：

```c++
class X{
……
		X& operator( )(参数表);
}；
```

其中的参数表可以包括任意多个参数。

3、运算符( )的调用形式如下：

X Obj;              		//对象定义

Obj()(参数表);  		//调用形式1

Obj(参数表);       		//调用形式2