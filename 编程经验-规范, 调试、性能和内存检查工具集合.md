# 编程经验 / 规范, 调试、性能和内存检查工具集合

程序调试、在检测工具手段上对程序评估和优化 的 综合。

分为很多块内容且相互独立，直接到对应小节。

*p.s 有的网络页面不让复制文本，没关系，有让网页内容变可复制的插件。自行搜索，这里只是提醒，因为这些小点的经验提醒、思路、渔最重要。*



尚有 一些 标记了 TODO 的地方 有待施工。没有三头六臂，很多资料 手头和脑里 都有 只是尚未没有整理出来。



> 虽抱文章，开口谁亲。且陶陶、乐尽天真。几时归去，作个闲人。对一张琴，一壶酒，一溪云。



# 编程经验 / 规范

这里只总结一些精华的点、易忘的点，高频出问题的点。



## 顶层指导

考虑 最佳实践 和 设计模式：

- **基础语法**和例子，实践的时候可举一反三使用。

- 多看一些 **最佳实践的文章和软件工程** 来对自己进行提高。

  关于看别人优秀代码实践的意义 [为了写好代码，你坚持了哪些好习惯？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/535244045)。

- 写东西时候先多思考架构。不必一上来就写 等 情况的出现，减少后面 debug 和 重构的时间。

  **设计模式**相关综合 [Staok/C-Cpp-design-patterns: C/C++设计模式相关优秀资料集子 (github.com)](https://github.com/Staok/C-Cpp-design-patterns)。



- 思考好一个工程的整体设计，层次化、模块化、跨平台化（如果需要），会 接口分明、模块独立、减少 bug（编写时就应减少bug）、容易理解、好 debug、易扩展 等。



考虑 一个工程统一规范和套路：

- 软件工程中，多人合作搭建 却慢慢变成 shit mountain，一大原因是很多地方没有约定好固定的写法，导致多个人各用各的方式写。就是一个人开发，也要前后一致的**制定和遵循一些规范和套路**。

  还有一个 shit mountain 缔造者，就是频繁改需求。没有万能的软件架构、结构，一开始想不清楚，拍脑袋想、随着开发和测试进行中还不断提新需求和改需求，这里改改哪里改改，开发没有仔细设计、优化、重构的喘息机会，还容易造成开发的设备开发不完备、运行不稳定、测试不全面、边缘 case 遗漏 等等 问题。shit mountain 就这么著成了。

  **解决**：

  - 版本提前封需求。
  - 需要介入一定强有力的统筹管理的角色。
  - 开发中，有意识的识别一些重复繁琐的步骤，进行、脚本化、自动化，对于个人也好，对于他人共同合作也好。

- 写好注释，方便 自己 和 他人 日后熟悉。一些供别人调用的类、功能函数、变量等，源文件里面注释写好用例，注释用 Doxygen 格式，可 VsCode 相关插件辅助。



考虑 自动化工具 和 测试：

- 可以设计 和 使用一些**自动化工具来帮助完成重复性的操作**（也避免人工操作的可能的失误，所以工具也要写的健壮一些，识别和处理一些常会出现的错误），或者 用来检查 容易出错的地方，借由机器来给脑卸去些负担。
- 分级测试，函数级别、任务级别、整系统联调级别。各个模块，自己写代码做压测（高并发的去测），可每天晚上跑一跑来压测最新的、各个组件、模块 的 代码，有没有内存泄漏、死锁、抛异常 的 crash 问题 等等。



考虑通用性：

- 考虑开发软件的硬件无关性、跨平台性 / 跨操作系统性（主要是 win 和 linux，如果考虑 mcu 那就得 c 去写）
- 具体结构上：首先层次化；各层次 模块化、组件化，可动态创建和销毁；代码 易扩展，尽量不会因为需求增加而大改甚至重构（设计模式）。



时而瞰之：

- 可以树立一个意识，对于各种领域都可以适用（而不只是硬件、软件、机械 等）：

  要做到 “既要又要”，**考虑到达目标的 新的 “模式”**，可能会同时解决之前到达模式中相互“矛盾”的指标。

- 并不是多码代码才好，这是工具，解决问题才是目的，时不时提醒，莫把工具当目的。

- 能自动化的步骤，全自动化，如 脚本化，工具化，如 尽量融入CI 编译管线，等等。

- 可以多问 AI，发散思考。

- 兴趣驱动 来 获得 能力 和 （普世价值）愿景，使用能力 由 需求驱动 来 创造价值、实现愿景。

  > “我第一次尝试 MidJourney（文生图工具）和 Suno（文生音乐工具）时，我想知道未来是否每个人都会成为数字艺术家。
  >
  > 很快，我就意识到我没有"创作冲动"，即使看过很多别人的创作，我也常常不清楚自己想要创作的东西。
  >
  > 因此，未来的 AI 即使具备无比强大的绘画和编曲能力，还是只有少数人能成为画家和音乐家。程序员也是如此，即使 AI 会编程，也无法人人成为程序员。”
  >
  > [科技爱好者周刊（第 330 期）：李开复梳理人工智能 - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2024/12/weekly-issue-330.html)。



## 易错注意

p.s 这些地方易错有些无法静态检查出，是运行起来碰到，目前还没有好的静态工具来检出，所以靠人来保证程序的健壮性，是良好的 程序框架设计 和 一些规则、规范 的 教育、培训、落实 来。



- 多线程访问公用资源的竞争。

  表现：程序 crash，变量不正常。

  避免：

  一个资源 的 创建、修改、删除 等：

  - 要么 确保都在一个线程（如 UI 线程 等）；

  - 要么 确保多个线程公用一把锁（锁类型：单纯的互斥量，或者读写锁 等，选择适当的锁类型，或者使用 atomic 类型变量），且确保用 RAII （如 std::lock_guard、std::unique_lock 等）的方式用锁：

    用锁，保证这块资源的多线程互斥；用一把锁，防止发生死锁（≥ 两把锁 时 写不好就有概率发生）；用RAII方式用锁，防止同线程中重复上锁。

  尽量用智能指针替换使用 new 和 delete。使用 new / delete 要加锁互斥，防止多个线程 重复 delete，而且这种 crash 和 coredump 比较难定位问题所在，std::shared_ptr 等智能指针管理对象创建和销毁是线程安全的。[C++ : shared_ptr是线程安全的吗？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/664993437)。所以尽早就定好原则、列清过往经验和风险点、沟通到位、大家一块写尽量健壮的代码。

  指针尽量不跨线程传递，防止指针指向的资源的销毁和修改的同步问题的易错点。

- 死锁。

  表现：程序卡住，但不 crash。使用锁且调用形成环的时候形成死锁。

  避免：

  确保调用不形成环，调用栈单向流动。

- 访问非法/失效指针。

  表现：运行到使用指针的点就 crash。

  避免：

  1. 指针（包括 std::shared_ptr 等类型的指针）加 判断 是否 为空 或 失效（在编码设计上、模块结构上入手，也不能永远加检查，增加程序运行负担）。

  2. 动态创建的资源，多用 智能指针 替代使用 new/delete。释放指针后 视情况 尽量 置其为 nullptr / null（如果对其它地方有用）。

     对于共享指针传参，可以传 赋值给 std::weak_ptr 类型 变量 来传递。用的时候使用 `if(auto sp = weak_ptr.lock()) { ... }` 来做，检查 weak_ptr 是否还有效，有效则继续执行 if 括号里面的，sp 还原为 std::shared_ptr 类型 则继续正常用。

  3. lambda 注意捕获变量的生命周期，尽量少捕获，对于非指针类型 多用 传参方式，尽量 不捕获和传参 指针变量 到 lambda 里面去用（有生命周期需要同步的问题，并且出问题还比较隐蔽难排查）。一个被捕获或传入的指针变量已经超出生命周期（比如释放掉了）再调用 lambda 并在里面使用这个指针变量，必 crash。lambda 内部 需要 外部指针下面的某个信息，在外面就取出，通过传参方式 把 非指针变量 传进去。

- 抛异常。

  表现：执行到回抛异常的函数 crash，程序结束也许会有打印。

  避免：

  会抛异常的 API 若有必要 / 尽量 加异常捕获。比如 如 std::stoi()，容器的 .at()、json 库 的一些 API 等等。接住异常并要打log。

  使用系统调用、库函数等，查看文档确定其是否会抛异常，处理其执行错误的情况。自己写程序可以尽量不用主动抛异常，运行出错当下解决（视情况严重性，是直接终止程序（后面依靠比较完备的测试来逐渐收敛程序 bug 来提高程序健壮性），还是及时在当下来处理错误（如给个默认值等））。

  调用有可能抛出异常的API（一般是库的），都要加 try cache 来打印 log 并处理现场。自己写的就不要抛异常了，只接不抛，否则代码规模一大不好控制。

- 数组、容器访问越界。

  表现：运行到访问 数组、容器 crash。

  避免：

  1. 确保 判断 和 处理 各种外部传入 的 index 值。
  2. 程序设计良好，在内部确保各个地方对 数组 或 容器 使用 index 不会发生越界等问题。如 使用 std 容器的 .at() 之前通过 检查 或 设计 保证不越界，或者调用容器的 .at() 等 的时候 使用 try catch 等。



## 良好实践经验 / 惯例写法



设计模式：

- 熟悉各种设计模式：参考自总结 [Staok/C-Cpp-design-patterns: C/C++设计模式相关优秀资料集子 (github.com)](https://github.com/Staok/C-Cpp-design-patterns)。

- 设计模式基本原则：

  - 类、模块、函数 等 保持单一职责，设计的尽量多复用，少一次性编程。

    针对可良好复用的接口编程，而不是特定的业务和实现。

    代码之间减少耦合，尽量减少相互侵入编程，尽量都是独立便携的模块。

    细节依赖抽象，抽象来保证继承、多态的复用。

  - 对于修改封闭，对于扩展开放。即多接口比单个接口但执行多种功能要好。

  - 基类出现的地方可替换子类而不改变程序行为原则，即 派生类对基类尽量不要重写（override）和重载，即倒逼去写 基类尽量是抽象类（至少一个虚函数）以及 派生类不要对基类写同名函数的重载。

- GSL（C++ Core Guidelines）的一些原则：
  - [C++ Core Guidelines (isocpp.github.io)](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#main)。
  - [C++ Core Guidelines 深度解析：现代 C++ 编程的终极指南-CSDN博客](https://blog.csdn.net/qq_22825391/article/details/147880360)。
  - GSL 库，主要服务于 检查 和 编码 符合 GSL 原则的代码。[microsoft/GSL: Guidelines Support Library (github.com)](https://github.com/microsoft/GSL)。[C++ Core Guidelines 中文版 GSL_c++ core guidelines解析 电子版-CSDN博客](https://blog.csdn.net/qq_36541069/article/details/134393151)。

- SOLID Design Principles：

  [SOLID Design Principles Explained: Building Better Software Architecture | DigitalOcean](https://www.digitalocean.com/community/conceptual-articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design)。

  - 



具体实践：



一些参考：也是对后面内容的补充

- 一个比较总的 [chengxumiaodaren/cpp-learning (github.com)](https://github.com/chengxumiaodaren/cpp-learning)。

  [C++ 编程指南 | C++ 编程指南 (chengxumiaodaren.com)](https://chengxumiaodaren.com/)。



- [比较优雅地编码 - 会长 - 博客园 (cnblogs.com)](https://www.cnblogs.com/zzy0471/p/coderule.html)。

  - 

- [《Effective C++》学习笔记 - 简书 (jianshu.com)](https://www.jianshu.com/p/4661bd7b7593)。

  - 

- [你最喜欢的c++编程风格惯用法是什么?_51CTO博客_c++编程惯用法](https://blog.51cto.com/u_12205414/3251768)。其中的一些精华总结到下面。

  - 

- [C++高效编程的12条建议：性能优化实践指南 | 性能优化 | C++ 编程指南 (chengxumiaodaren.com)](https://chengxumiaodaren.com/docs/performance/advice/)。

  > - 对于函数本身会拷贝的参数，**值传递并在函数内移动赋值给内部变量**实际上是向函数传递参数的最佳方式。
  > - 按值返回对象通常没啥大问题。而且一般情况下他们会触发返回值优化或移动语义，即不会有多余的拷贝动作。因此 **按值返回 就好**。
  > - **传递内容，可多用移动语义**。尽量确保对象拥有移动构造函数和移动赋值运算符。对象有了移动语义后，许多操作都会更加高效。
  > - 短函数可以使用内联消除函数开销。但增加 size，平衡看待。
  > - 不用 递归，而是**选择 迭代 / 循环 方式**。
  > - **对于频繁执行的耗时操作，就用缓存，空间换时间**。
  >   - 预分配内存。比如标准化容器中的reserve，需要频繁创建内存的地方可以考虑预分配一块内存出来，避免频繁的创建内存。
  >   - 磁盘访问：如果频繁访问一个文件，可考虑将这个文件的内容保存在内存中。
  >   - 数学计算：某些很耗时很复杂的运算，可考虑只执行这种计算一次，然后共享结果。
  >   - 对象分配：如果需要大量频繁创建和销毁短期对象，可考虑使用对象池。
  >   - 线程创建：如果需要大量频繁创建和销毁线程，可考虑使用线程池。
  >
  > - **选择效率更高的算法**。
  > - **多用profiling工具**，检查出性能瓶颈点进行优化，有针对的优化。

- [federico-busato/Modern-CPP-Programming: Modern C++ Programming Course (C++03/11/14/17/20/23/26) (github.com)](https://github.com/federico-busato/Modern-CPP-Programming)。

  > The course covers the basics of C++ programming and moves on to advanced C++ semantics and concepts.
  >
  > - *Practical teaching*: non-verbose, short structured descriptions associated with code
  > - *Minimal code examples* for showing just a specific feature or issue without digressing
  > - *Complementary language aspects*: tools, coding conventions, project organization, and code optimization
  > - *Experience-based*: many aspects, examples, and problems come from real-world cases faced during my work as software engineer

  - 



类：

- 基类/抽象类、派生类 的结构设计尽量按照实际情况，尽量分层次处理，基类/抽象类中列好公共 变量 和 接口/虚函数/纯虚函数 等。

  对于一类的事物，每个事物用类封装，它们最好有个共同的抽象基类（继承其），并且每个具体事物的类里面 override 所有抽象基类的虚函数（形成多态）；若这些事物要随时创建，搞一个它们的工厂类（抽象工厂模式）来用 比较通用的接口 通过 不同的入参 来创建不同的一类事物 并返回他们的基类类型指针（用 如 std::make_shared 来创建）；在具体的地方用 vector、map 等方式存储它们的智能指针（如 std::shared_ptr）来存着他们，或专门写个创建并管理它们的类（增删改查判排复）且用 LRU 的方式存储他们以实现 有序排列的同时 实现 增加、查询 均为O(1) 复杂度。

  上面的总结：

  - 类抽象、集成和多态，符合直觉的构造有意义的方便使用的数据结构。
  - 对这些类对象的管理，尽量多做/多用 RAII（利用对象生命周期管理资源）风格编码，如 使用 智能指针。
  - 抽象工厂模式创建；容器管理，或写个 LRU 来管理。

- 创建和销毁资源务必成对去写。创建资源（类、结构体、数组等）用于承接的指针尽量使用 std::shared_ptr / std::unique_ptr 这种（尤其是 在异常等情况发生时，资源可以自动释放）。

- 使用 智能指针 替代 new/delete 和 malloc/free。具体看上 `易错注意` 里面 对于智能指针使用的描述。

- 类的析构，实例的删除等等的函数，做到可重复多次调用（因为外部有可能重复调），可用 mIsInit 变量（使用 atomic 类型 或 互斥锁，考虑线程安全）来记录这个类是否初始化成功，类的各个方法开头先判断一下这个。delete 前 先 判断指针 是否不为空，delete 后指针再置空（nullptr）。




函数：

- 函数实现尽量降低 圈复杂度。视场景而定，有时还需要为了可读性，或可注释、文档描述清楚。

- 函数保持短小精悍。若有多个循环则拆分出单独函数，若有复杂的判断条件则也拆出单独的函数。

  > **"Give someone state and they'll have a bug one day, but teach them how to represent state in two separate locations that have to be kept in sync and they'll have bugs for a lifetime."** [ocornut/imgui: Dear ImGui: Bloat-free Graphical User interface for C++ with minimal dependencies (github.com)](https://github.com/ocornut/imgui)。
  >
  > DeepSeek 翻译为：单一状态顶多偶尔出错，双份状态终身调试不休。

- 复杂函数放在 .c/.cpp 源文件 中定义；不超过10 行的、高频调用的，公用函数性质的、短平快的，可在 .h 中 写为内联函数。在 .h 中定义实现的函数均会被生成为内敛函数。

- 函数返回值一般为有符号整数表示执行结果，执行成功 使用 0，出错 使用 负值（使用 [errno.h](https://baike.baidu.com/item/errno.h/4565401)），正值表示执行成功但是可能带点问题（个人习惯，使用返回的正数区分是什么警告级别的问题）。

  对外接口性质的函数：

  - 需要入参检查，因为外部传入不确定。

  - 根据 GSL（C++ Core Guidelines） 的契约检查，入参检查分为：前置检查，后置检查。

    - 前置检查：在执行操作之前进行的检查，确保所有的先决条件都已经满足，如果条件不满足，则操作不会执行，程序可以立即返回错误或抛出异常。

      即 检查外部给我的是否是好的。

    - 后置检查：在操作执行之后进行的检查，验证操作的结果是否符合预期。如果结果不符合预期，则可能需要进行错误处理或修正。

      即 检查我给外部的是否是好的。

  - 考虑入参检查的策略，是检查少数错误的情况并返回错误值，还是检查少数正确的情况才执行，从检查的复杂度上选择复杂度小的。

  内部使用的一些函数：

  - 函数入参的检查，不必总是执行（尤其是复杂的检查），从整体设计上出发入手，考虑是否有必要检查（模块、类的内部使用的很多函数从设计上入手，不需要总是检查入参，会增加运行负担），可不检查就不检查。如果模块内部使用函数因为入参产生错误，那么大概率是模块内部设计问题，需要主动消除，而不是依靠入参检查。
  - 不必所有函数都需要返回值来指示执行结果成功与否，首先一些释放资源的函数不需要，其它的很多函数其实也可以不需要，需要从整体结构上设计入手，因为实际调用它们的时候并不会总是检查返回值，无意义的、根本就不会出错的返回值检查也会增加运行负担。

  

- 凡是函数就考虑线程安全。使用 RAII 风格 加互斥锁。

- 函数形参，适当使用引用，标准库容器 适当使用 emplace 等 右值引用 来传递值，减少拷贝。

  返回内部参数，可直接写成拷贝返回即可（编译器 的 返回值优化（RVO）），返回指针、引用等容易增加 不确定性 问题，如 资源生命周期同步问题等。

- 执行体中，可常用 大括号 `{ ... }` 包裹较独立的多段语句，控制其内部临时变量的生命周期，能提前结束的就可以提前结束。

- 可以更多的使用模板元编程。



Misc：

- 项目的多个模块之间使用命名空间做划分。尤其是对于很多具有全局性质的比如 传统枚举、宏 等。
- 使用 枚举类 替代 传统枚举。

- 多用 编译期 的 检查 和 计算。static_assert，以及 一些表达式使用 constexpr 替代 宏。



注释：

- 主旨是：方便自己日后回忆；方便他人熟悉程序流程 和 究竟这段想要干什么。

- 注释均使用 doxygen 格式。

- 文件头、类、函数、一些变量。头文件中使用注释对类、类方法等对外接口描述清晰，给出几个使用例子（可选，但很推荐）。

  函数内部实现的注释可以用 普通的 双划线 注释，即 对于单行注释，优先使用 `// xxx`，而不是 块注释 `/* xxx */`。

- 有必要 注释 标注 的 要素有：

  - 头文件里面对外的元素都尽量加上注释辅以说明，如 文件开头（版权说明、协议 等）；
  - 类声明；
  - 类对外的 变量成员 和 方法成员 等。
  - 头文件里面最后可以给几个 example 来 打样 本头文件 的 类 或 函数 的基本用法。
  - 编码关键点、易忘点、细节加上注释。



## 细节写法 / 格式 / 注意点

也是对上面内容的更多补充。



- [Staok/coding-style-and-more: C 编写规范和其他 (github.com)](https://github.com/Staok/coding-style-and-more)，[gitee 地址](https://gitee.com/staok/coding-style-and-more)。个人总结的一些 编程 经验 和 写法规范，主要针对 mcu c 的，个人早期的总结（自己的一些经验、网搜很多良好的经验、写法等 的 集合）。

- [编译优化 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/lang/optimizations/)。

- [Google 开源项目风格指南 (zh-google-styleguide.readthedocs.io)](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/index.html)。

- 基础要素 / 思想指导：
  - 代码格式，以具有良好的可读性为好。整个工程整齐划一，**风格和编程模式具有连贯性**。

    每个项目最好都有统一的 .clang_format 文件，时常 format 下。

  - **层次化**，**模块化 / 结构化**。（按需）跨平台化。

    **可读性**：

    - 有基本注释，.h 文件 中用注释出用例、测试建议 / 测试用例，对外的 函数接口、类、数据结构 等 接口 用 doxygen 注释上。具体注释要求看上 `良好实践经验 / 惯例写法` 里面的 对于注释的要求。
    - 出文档用文/图/表等 把内部各部分之间流程、关系 和 对外接口 描述清晰。

  - 编码实现：**高内聚、低耦合，不宜常修改，应易扩展**。

- 基本格式：

  - 单文件最多尽量控制在 1200 行以内 或 左右。

    函数最多尽量控制在 100 行以内。一个函数执行功能保持单一。

    每一行最好不要超过100个字符在，超过部分选择在合适位置换行。

    这样，倒逼在前期设计、模块结构、编码实现上多思考。

  - 注释，优先使用 doxygen 格式。具体注释要求看上 `良好实践经验 / 惯例写法` 里面的 对于注释的要求。

  - 默认缩进 4 个空格，不要使用 tab。多行宏也是用缩进。预处理相关代码如 `#if` `#ifdef` 等，看情况也要缩进。

  - 使用 utf-8 编码。

  - 不要有无意义的空格，行尾不要有空格。

    文件结尾保留一个空行。（这些可使用 VsCode 的 trim 相关设置参数）

  - 函数等之间留有一个空行。

    两个空行用于大段分割。

    不要有多于两个空行。

  - switch case 语句中，case 与 switch 对齐，case 内部 执行多于一个语句，就使用 大花括号 括起来 多个执行语句。

  - 函数的花括号，执行体内用于分范围的花括号，左括号另起一行，右括号与之竖向对齐。

    其它语句的花括号如 if、for、while 等不必另起一行，其中的关键字和圆括号、花括号等之间空一格。 

  - 类的 public、private 等关键字 与 class 对齐。

    namespace 所包裹的内容不用增加缩进层次。

    预编译执行所包裹的内容不用增加缩进层次。

- 命名相关：
  - （尽量）全部用驼峰命名法，紧凑易读。

  - 文件名、类名、结构体名、枚举名、枚举值名、宏名 等：首字母大写的驼峰命名法（帕斯卡命名法）。

    枚举值名、宏名可加下划线来分割。

  - 函数、局部变量，首字母小写。

    类的变量，使用 m 开头。

  - 普通函数、类的方法成员：

    写 和 读 的方法函数命名惯例使用 set / get 作为前缀（set 函数里面 首先判断设置值是否与当前相同，不同才设）；

    返回 bool 类型的函数使用 is 作为前缀，对于 set 或者 get 的函数， 前缀为 setIs 和 getIs。

    回调函数命名结尾使用 Callback 或 Cb。

    绑定回调函数、槽函数的函数使用 on 作为前缀。

  - 文件 内部用 函数 使用 下划线开头，一般使用 `static <return type> _xxx(...) { ... }` 格式来。

  - 变量：类内变量成员，m开头；其它变量，尽量遵循驼峰命名法；bool 类型的可以使用 is 开头；指针类型的可以用 ptr 结尾；回调函数变量可以以 cb 结尾；设置回调函数以 onChange 等标明；等等。

  - 宏：全大写 + 下划线，宏函数 的函数部分 推荐用 `do { ... } while(0)` 包起来，使用的时候以加分号结尾。

- 函数 / 变量：
  - 类、函数定义考虑可扩展性，函数入参较多则考虑使用结构体打包。函数入参不必下划线前缀。

    函数形参超过三个的，考虑 使用 struct 打包（后续补充形参也可直接修改这个结构体，比较方便维护），传递参数尽量不用 std::array, std::pair, std::tuple 等这种 破坏可读性 的东西。较多参数、可能变化的参数群 可以 封装为 struct。

  
  
  - 尽量少用 std::string 等比较重的变量作为 index，而尽量都用枚举或整数。
  
  - 枚举，里面变量命名首位加枚举类型名，用于每个枚举变量全局唯一，要么就用枚举类，这样不用在命名上麻烦。例子如下：
  
    ```c++
    enum TempEnum {
        TempEnum_NumA = 0,
        TempEnum_NumB,
        // ...
        TempEnum_MAX,
    };
    
    // ↓
    
    enum class TempEnumClass {
        NumA = 0,
        NumB,
        // ...
        MAX,
    };
    
    enum class TempEnumClass1 {
        NumA = 0,
        NumB,
        // ...
        MAX,
    };
    ```
  
  - 宏定义的内部最后不已分号结尾，且写成要求调用的时候得加分号结尾（可用 do{ ... }while(0) ），当作函数调用的形式。
  
  - 32 位机器尽量使用 32 位整型，少用 8、16 位整型。



- 打印 log 的一些规范，有用的 log 优化常用方法：
  - 日志 log 中 隐私（企业、个人（用户））相关信息不要打印到 log 中。
  - 降频；比较前后数据，有变化时再打印；只打印 error 错误信息，以及关键 info 信息。
  - 比较稳定且不重要的模块尽可能精简，出了问题再加 log 也来的及。
  - log 描述尽量简化，单词用缩写，函数名不用打全。



## 分析 Coredump 步骤

基本命令：

- gdb 查看 coredump：`gdb {binary} {coredump_file}`

- gdb 查看 coredump 并 指定 sysroot 目录：`gdb -ex "set sysroot $SYSROOT_PATH" -ex "bt" {binary} {coredump_file}`



解 coredump 或 crash 步骤：

1. 拿到log，初步分析最后程序停止的地方。

2. 拿到对应的 coredump 文件 和 sysroot。源码还原到当时的状态，对照着 coredump 的 调用栈 分析。

3. 查看 coredump，确认 signo，使用 gdb 到现场查看环境，使用命令：

   `bt`，`f <num>`，`info args`，`info locals`，`info frame`。

   如果初步没有头绪，则看看其它线程都在干什么 `thread apply all bt`，使用 `thread <thread-id>` 跳转到对应的线程号，再用 `bt` 查看调用栈。

4. 如果看不出crash的点或者死锁的可能，那么看看此时机器的cpu和内存占用是否正常。是否是其它进程挤兑。



# 环境搭建 最佳实践

这里面也是对本文下面各种工具的整理。

必利其器：

- 对于 VsCode 作为 IDE，使用 clangd 作为辅助，项目根目录使用 .clangd 配置文件（里面也可以添加 clang-tidy 相关的内容，加上 cppcheck 静态检查工具）。工程 Debug 态 编译 使用 ASAN 等动态检查工具。

  具体参考自己 VSCode + CMake 模板工程（有待出）。

- 对工程制定统一编码规则，基本格式等，使用 clang-format 来处理。





TODO 引用 自己的 cmake模板工程仓库目录



# GDB / ADB / binutils / GCC options

## GDB / GDBServer

基本步骤 [Debugging With gdb Mini-Tutorial | hacking C++ (hackingcpp.com)](https://hackingcpp.com/cpp/tools/gdb_intro.html)。

更丰富各种基础 GDB 资料 [ARM-Linux-Study/【1 GCC & GDB & GDBServer】 at main · Staok/ARM-Linux-Study (github.com)](https://github.com/Staok/ARM-Linux-Study/tree/main/%E3%80%901%20GCC%20%26%20GDB%20%26%20GDBServer%E3%80%91)。

更丰富内容 [C++ 构建调试指南 | C++ 编程指南 (chengxumiaodaren.com)](https://chengxumiaodaren.com/docs/build-debug/)。

gdbinit 文件 [Ubuntu轻松上手：从零开始安装与配置GDB调试工具 - 云原生实践](https://www.oryoy.com/news/ubuntu-qing-song-shang-shou-cong-ling-kai-shi-an-zhuang-yu-pei-zhi-gdb-diao-shi-gong-ju.html)。



对于 gdb 工具，若是单步调试等这种，一般有 VsCode、VS 这种界面工具，对于 GDBServer 则需要 一些单步调试命令。而对于 linux 产生的 coredump，更多是在使用 gdb 的各种信息查看命令。



**GDB 常用命令总结**

- `gdb ./your_program` 启动 GDB 时指定目标程序。
- `run` 运行。
- `break my_program.c:10` 设置断点；`break otherfile:func` 某文件某函数入口处设置断点。
- `info b` 列出所有断点和其编号。`delete n` 删除某编号断点；`delete` 删除所有断点。`disable/enable n` 失能/使能某编号断点。
- `step` 或 `next` 单步执行。
- `quit` 退出。



- `bt` 显示调用栈。
- `f <num>` 设置当前处于哪一层栈，再用 `info <xxx>` 的命令看看信息，常用的：`info locals`、`info args`、`info frame`，然后可以用 print 打印变量、结构体、指针等等。
- `p <valName>` 打印变量。
- `thread apply all bt` 显示所有线程在干什么。
- `thread <thread-id>` 跳转到对应的线程号，再用 bt 查看调用栈，同上。



**coredump 相关**

gdb 查看 coredump `gdb {binary} {coredump_file}`。指定 sysroot 目录，在 gdb 后添加 `-ex "set sysroot $SYSROOT_PATH"`。

Linux 程序调试，产生 coredump 方法

[浅谈 Linux 中的 core dump 分析方法-CSDN博客](https://blog.csdn.net/qq_42417071/article/details/140147831)。

[Linux内核调试方法总结之coredump - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/514516021)。

[一文教你快速上手GDB程序调试 - 知乎](https://zhuanlan.zhihu.com/p/196763202)。

需要编译程序 添加调试 -g，将符号表导出到 bin，可供 gdb 查询；可以开发阶段都是用这种编译，最后 release 的时候，可以稍微使用优化比如 -O2，然后去掉 -g 或者 使用 gcc 的 strip 工具给 bin 去掉 符号表。



程序编译时候 -g 会带上函数等符号，使用以上工具可以根据内存地址反查出函数名，若只有内存地址，可以用 gdb 工具

[c++ - How to use GDB to find what function a memory address corresponds to - Stack Overflow](https://stackoverflow.com/questions/7639309/how-to-use-gdb-to-find-what-function-a-memory-address-corresponds-to)——在 gdb 工具里面使用 info 系列命令来查看



## ADB



adb 常用

- adb pull
- adb push
- adb shell



基于 SSH 收发文件的，使用 `scp` 命令。



一个 adb UI

[nightmare-space/adb_kit: A Better ADB GUI and More Than a ADB GUI](https://github.com/nightmare-space/adb_kit)。



## binutils 工具集

binutils 工具集介绍和使用 [GNU开发工具——GNU Binutils快速入门_51CTO博客_GNU Binutils](https://blog.51cto.com/quantfabric/2515980)。

包括 addr2line、ar、gprof、nm、objcopy、objdump、ranlib、size、strings、strip。



**addr2line 使用详解**

[在Linux中使用addr2line的参数有哪些 - 问答 - 亿速云 (yisu.com)](https://www.yisu.com/ask/96420422.html)

[addr2line使用详解_addr2line命令用法-CSDN博客](https://blog.csdn.net/zhangqi306891687/article/details/141498310)

[调试厉器addr2line-CSDN博客](https://blog.csdn.net/mingtiannihaoabc/article/details/131263823) 程序地址、库方法地址、内核模块的地址

一般用法 `addr2line -e <bin> -Cfp <addr(0xXXXX)>`



## GCC 实用选项

*p.s 不断积累在这里。*



gcc 选项 `-finstrument-functions` 实现函数调用栈追踪

[gcc 选项-finstrument-functions实现函数调用栈追踪-CSDN博客](https://blog.csdn.net/m0_61549061/article/details/139065079)。



gcc 扩展关键字，可多了解和积累

`__attribute__`：

[__attribute__ 的详解 - 简书 (jianshu.com)](https://www.jianshu.com/p/c8bea3807527)

[GNU C中不为人知的特色：__attribute__机制-CSDN博客](https://blog.csdn.net/juana1/article/details/6849120)

[__attribute__机制介绍-CSDN博客](https://blog.csdn.net/ithomer/article/details/6566739)

[__attribute__机制介绍_使用-finstrument-CSDN博客](https://blog.csdn.net/bytxl/article/details/7523472)



# 编译优化



- 公共头文件不使用 `__DATE__` 之类的时间宏，每次编译都需要重新编译的。
- cmake 对公共的且比较重的头文件使用 prebuild。
- 



# 性能优化注意点集合



- [假如我号称精通C++，你作为考官准备怎么难住我？ - 知乎](https://www.zhihu.com/question/825891126)。



常见性能卡点：

- 操作数据耗时。数据对齐为系统位数长度。
- 内存已经碎片化 或 小内存频繁申请和释放，malloc 时间显著延长。使用 内存池 或 对象池。
- 锁占用耗时。优化为无锁。
- 



# 性能 / 内存相关工具

参考：会列出很多工具，选择自己趁手的即可。

- [一般Linux性能调优都用什么工具？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/448362493/answer/1770329163)。
- [C/C++ 编程有哪些值得推荐的工具？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/23357089/answer/1992218543)。
- [C++ 怎么检测内存泄露，怎么定位内存泄露？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/63946754/answer/1981098265)。
- [大型c++项目在linux下如何调试? - 知乎 (zhihu.com)](https://www.zhihu.com/question/26905808/answer/1971302757)。



- [C++ 性能优化指南 | C++ 编程指南 (chengxumiaodaren.com)](https://chengxumiaodaren.com/docs/performance/)。

  [C++性能优化工具大全：从静态分析到动态检测 | 性能优化 | C++ 编程指南 (chengxumiaodaren.com)](https://chengxumiaodaren.com/docs/performance/opt-tools/)。



## Linux 系统常用工具

> **网络I/O**：dstat、**tcpdump**（推荐）、sar
>
> **磁盘I/O**：**iostat**（推荐）、dstat、sar
>
> **文件系统空间**：**df**、du
>
> **内存容量**：free、**vmstat**（推荐）、sar
>
> **进程内存分布**：**pmap**
>
> **CPU负载**：uptime、**top**
>
> **CPU使用率**：**pidstat**（推荐）、vmstat、mpstat、top、sar、time
>
> **系统调用追踪**：**strace**（推荐）
>
> **网络吞吐量**：**iftop**、nethogs、sar
>
> **网络延迟**：**ping**
>
> **上下文切换**：**pidstat**（推荐）、vmstat、perf
>
> **软中断/硬中断**：**/proc/softirqs**、**/proc/interrupts**



各种工具用处可视化的各种图

[Linux Performance (brendangregg.com)](https://www.brendangregg.com/linuxperf.html)。



## 内存统计基本命令

[Linux 下查看内存使用情况方法总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/555018970)。

[linux进程VSZ（Virtual Memory Size 虚拟内存）RSS（Resident Set Size 驻留集大小，实际占用的物理内存）PSS、USS、ANON、RESVIRTDirty-CSDN博客](https://blog.csdn.net/Dontla/article/details/123131147)。



- procrank 查看各进程的 VSS RSS PSS USS 内存占用情况

  VSS RSS PSS USS 内存 介绍 [VSS/RSS/PSS/USS - 简书 (jianshu.com)](https://www.jianshu.com/p/995692aa0100)

  `procrank -u -R`

  `watch -n 1 procrank -u`（循环执行）

  ```bash
  watch -n 1 "procrank -u | grep <process_name>"
  ```

- `ps aux --sort -rss`

- `free -h`	对 /proc/meminfo 收集到的信息的一个概述

  进程的内存使用信息也可以通过 `/proc/<pid>/statm` 和 `/proc/<pid>/status` 来查看，但比较抽象，有具体的格式

- pmap 命令

  [如何在 Linux 上使用 pmap 命令_linux pmap使用-CSDN博客](https://blog.csdn.net/wlcs_6305/article/details/124434626)

  [Linux内存管理 -- smaps讲解-CSDN博客](https://blog.csdn.net/qq_34934140/article/details/121120348)

  [anon] 内存段 [系统调用mmap的内核实现分析-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1459253)

  - 该内存段就是操作系统为mmap系统调用新分配出来的区域。

  - frame buffer 算，其它的还有可能是 别的系统调用 通过 mmap 读写 驱动文件 产生的

  `pmap -p -x <pid>` 查看某一个进程的内存占用各个文件的信息，`-x` 以及 `-X` 和 `-XX` 选项增加显示信息

  `pmap -p -x <pid> > /tmp/xxx` 写入到文件，再取出到 pc 上，导入到 excel，排序查看，或者用别的方法排下序来看。

  循环监视：

  ```bash
  watch -n 1 "pmap -p -X $(pidof <procss_name>) | grep heap"
  ```



## 动态检查 *



几个主要工具对比

> | 工具       | 使用命令                                                     | 是否需要重新编译 | Profiling速度 | 是否支持多线程热点分析 | 是否支持链接库热点分析 |
> | ---------- | ------------------------------------------------------------ | ---------------- | ------------- | ---------------------- | ---------------------- |
> | gprof      | ./test; gprof ./test ./gmon.out                              | **是**           | 慢            | **否**                 | **否**                 |
> | valgrind   | Valgrind --tool=callgrind ./test                             | 否               | **非常慢**    | 是                     | 是                     |
> | gperftools | LD_PRELOAD=/usr/lib/libprofiler.so CPUPROFILE=./test.prof ./test | **否**           | 快            | 是                     | 是                     |



### valgrind

拖慢程序比较严重，不推荐使用了其实。后面的 prof 工具类 和 AddressSanitizer 推荐使用。

可参考：

[valgrind Introduction | hacking C++ (hackingcpp.com)](https://hackingcpp.com/cpp/tools/valgrind.html)。



一些使用和调试经验

可以查看程序的堆内存分配情况，包括哪些函数分配了大块内存。

https://www.cnblogs.com/jj-Must-be-sucessful/p/17005792.html    编译和添加环境变量

https://baijiahao.baidu.com/s?id=1652356863601374476&wfr=spider&for=pc    检测内存泄漏

https://blog.csdn.net/asitMJ/article/details/135371794 linux多线程互斥锁程序卡死排查



qt creator 中自带：（在Linux中）需要先安装 Valgrind 并添加环境变量，并测试能用，然后在 qt creator 中实用如下功能启用监控和生成结果（火焰图等）`Valgrind Memory Analyzer (External Application)` 和 `Valgrind Function Profiler (External Application)`。

[QT-Valgrind内存分析_我不是萧海哇的技术博客_51CTO博客](https://blog.51cto.com/xiaohaiwa/5380249)，qt（linux pc）中执行



### gperftools + pprof *

> - gmc: gperf memory check, 内存检查（泄漏，错误等）内存泄漏检测工具
> - gmp: gperf memory profile, 内存性能分析（哪个函数内存分配多）内存占用分析。内存申请记录（定位到函数）。
> - gcp: gperf cpu profile, CPU性能分析（函数消耗CPU多）能够通过统计一定时间内各个功能单元（线程、函数等）的执行时间并给出其占用比例。cpu（函数调用 / 火焰图）。

> 相比与其他性能分析工具，**gperftools有Profiling速度快，灵活性较高的优点。**

但是配置起来需要安装一堆东西，需要专门用时间进行 学习、细细配置和使用起来。

> Gperftools 在 Windows 上提供了 tcmalloc_minimal 的支持，这是一个内存分配器，可以在 Windows 上使用。然而，一些依赖于 Linux 特有功能（如signal.h）的功能（如 ProfilerStart() 和 ProfilerStop() 函数）在 Windows 上不可用‌



基本使用：

1、以链接动态库的形式链接进程序。

2、也可以不重新编译程序，将库放到机器上，使用 LD_PRELOAD 环境变量指定加载库。

让程序启用，然后 pprof 打印内存申请情况。



使用上，建议不要自己编译 gperftools 生成库来给自己 程序 链接 和 编译，坑很多（大多数人生苦短，若你人生自由有时间，可以多研究多鼓捣），所以建议尽量使用编译好的lib 或者 现成的 package 来用（本文作者截止到 23.10（自己编译 gperftools 源码 然后链接成功，但是 bin 没有跑起来..） 还没有这么做过），推荐探索下（本文作者目前还没有这方面需求所以就没有花时间再深入研究，若日后正式再去用，则会记录成功的普适的步骤并补充到这里）。



参考：

[gperftools/gperftools: Main gperftools repository (github.com)](https://github.com/gperftools/gperftools)。

官方文档：

> ```
> TCMALLOC
> --------
> Just link in -ltcmalloc or -ltcmalloc_minimal to get the advantages of
> tcmalloc -- a replacement for malloc and new.  See below for some
> environment variables you can use with tcmalloc, as well.
> 
> tcmalloc functionality is available on all systems we've tested; see
> INSTALL for more details.  See README_windows.txt for instructions on
> using tcmalloc on Windows.
> 
> when compiling.  gcc makes some optimizations assuming it is using its
> own, built-in malloc; that assumption obviously isn't true with
> tcmalloc.  In practice, we haven't seen any problems with this, but
> the expected risk is highest for users who register their own malloc
> hooks with tcmalloc (using gperftools/malloc_hook.h).  The risk is
> lowest for folks who use tcmalloc_minimal (or, of course, who pass in
> the above flags :-) ).
> 
> 
> HEAP PROFILER
> -------------
> See docs/heapprofile.html for information about how to use tcmalloc's
> heap profiler and analyze its output.
> 
> As a quick-start, do the following after installing this package:
> 
> 1) Link your executable with -ltcmalloc
> 2) Run your executable with the HEAPPROFILE environment var set:
>      $ HEAPPROFILE=/tmp/heapprof <path/to/binary> [binary args]
> 3) Run pprof to analyze the heap usage
>      $ pprof <path/to/binary> /tmp/heapprof.0045.heap  # run 'ls' to see options
>      $ pprof --gv <path/to/binary> /tmp/heapprof.0045.heap
> 
> You can also use LD_PRELOAD to heap-profile an executable that you
> didn't compile.
> 
> There are other environment variables, besides HEAPPROFILE, you can
> set to adjust the heap-profiler behavior; c.f. "ENVIRONMENT VARIABLES"
> below.
> 
> The heap profiler is available on all unix-based systems we've tested;
> see INSTALL for more details.  It is not currently available on Windows.
> 
> 
> CPU PROFILER
> ------------
> See docs/cpuprofile.html for information about how to use the CPU
> profiler and analyze its output.
> 
> As a quick-start, do the following after installing this package:
> 
> 1) Link your executable with -lprofiler
> 2) Run your executable with the CPUPROFILE environment var set:
>      $ CPUPROFILE=/tmp/prof.out <path/to/binary> [binary args]
> 3) Run pprof to analyze the CPU usage
>      $ pprof <path/to/binary> /tmp/prof.out      # -pg-like text output
>      $ pprof --gv <path/to/binary> /tmp/prof.out # really cool graphical output
> 
> There are other environment variables, besides CPUPROFILE, you can set
> to adjust the cpu-profiler behavior; cf "ENVIRONMENT VARIABLES" below.
> 
> The CPU profiler is available on all unix-based systems we've tested;
> see INSTALL for more details.  It is not currently available on Windows.
> 
> NOTE: CPU profiling doesn't work after fork (unless you immediately
>       do an exec()-like call afterwards).  Furthermore, if you do
>       fork, and the child calls exit(), it may corrupt the profile
>       data.  You can use _exit() to work around this.  We hope to have
>       a fix for both problems in the next release of perftools
>       (hopefully perftools 1.2).
> 
> 
> EVERYTHING IN ONE
> -----------------
> If you want the CPU profiler, heap profiler, and heap leak-checker to
> all be available for your application, you can do:
>    gcc -o myapp ... -lprofiler -ltcmalloc
> 
> However, if you have a reason to use the static versions of the
> library, this two-library linking won't work:
>    gcc -o myapp ... /usr/lib/libprofiler.a /usr/lib/libtcmalloc.a  # errors!
> 
> Instead, use the special libtcmalloc_and_profiler library, which we
> make for just this purpose:
>    gcc -o myapp ... /usr/lib/libtcmalloc_and_profiler.a
> ```

可视化显示结果数据使用 pprof，[google/pprof: pprof is a tool for visualization and analysis of profiling data (github.com)](https://github.com/google/pprof)。

> pprof is a tool for visualization and analysis of profiling data



[GPERF 内存和性能分析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/608605973)。

[你了解过Gperftools性能分析神器吗？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/678172638)。

[gperftools的安装使用说明_gperftools安装-CSDN博客](https://blog.csdn.net/fpcc/article/details/136573180)。



[使用heap profiler进行内存占用分析 - 溟漓 - 博客园 (cnblogs.com)](https://www.cnblogs.com/minglee/p/10124174.html) 安装和使用

[gperftools快速上手教程 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/623443812)。

[使用google perf工具来排查堆外内存占用 | KL's blog (qsli.github.io)](https://qsli.github.io/2017/12/02/google-perf-tools/) 具体使用

[性能测试工具Google perftools（简称gperftool)配置及使用_google perftools使用-CSDN博客](https://blog.csdn.net/m0_50179075/article/details/125141931) -lprofiler -lunwind

[gperftools安装与使用-CSDN博客](https://blog.csdn.net/qq_44407144/article/details/131313020) HEAPCHECK=模式



有许多使用上的选项，可以详细参考 官方文档，总之功能是相对丰富的。



### gcc -pg + gprof

> 一种用于分析程序性能的工具，它能够生成函数级别的性能分析报告，帮助开发人员找出程序中的瓶颈和性能问题。`gprof` 通常与 GNU 编译器集合中的 `gcc` 配合使用，它通过在程序中插入一些特殊的代码来收集运行时的函数调用信息，然后生成性能分析报告。

> gprof可以用来分析系统在运行时各函数调用的次数，耗时等情况，可以方便地帮助我们定位系统的瓶颈，同时也能让我们知道对程序的那个位置就行优化能够带来尽可能大的性能提升。gprof 优化尤其适用于CPU、内存密集性的应用模块。

> -p / -pg： gcc 中的一个编译选项，用于在生成的可执行文件中插入性能分析代码，以便进行性能分析和 profiling（性能剖析）。以帮助开发人员了解程序的运行时间分布、函数调用关系以及性能瓶颈，从而指导优化工作。需要注意的是，由于插入了额外的代码，使用 -pg 选项可能会稍微影响程序的执行速度，因此在进行性能分析时需要权衡是否使用该选项。

不适用于 多线程 程序 分析（默认只记录主线程，分析多线程需要一些方法来做到。个人觉得，与其这折腾这个，不如直接用 gperftools 等来做分析） 和 动态链接库 的 分析。

gprof 可以统计出各个函数的调用次数、时间、以及函数调用图。

在编译和链接程序的时候，使用 `-pg` 选项；执行程序；再 `gprof <app> <运行结束后生成的分析结果文件>`。

> 1. gcc -pg 编译程序
> 2. 运行程序，程序退出时生成 gmon.out
> 3. gprof ./prog gmon.out -b 查看输出

> 可通过`gprof -h`命令查看可用参数。



[性能优化之性能分析工具gprof - 懒人李冰 (lazybing.github.io)](http://lazybing.github.io/blog/2019/04/13/profiler-gprof/)。

> 生成的分析文件 analysis.txt 中有两种形式的分析数据。
>
> Flat Profile 和 Call Graph。都是用于表示 每个函数的 占用时间 和 调用次数等。



[程序性能分析工具—gprof-CSDN博客](https://blog.csdn.net/tongxin1101124/article/details/115248122)。

> 由于结果report.txt分析不太直观，可以借助gprof2dot.py与dot工具生成函数调用图



[gprof性能分析工具详解-CSDN博客](https://blog.csdn.net/mozun1/article/details/58011427)。

> 注意事项
>
> - 程序如果不是从main return或exit()退出，则可能不生成gmon.out。
> - 程序如果崩溃，可能不生成gmon.out。
> - 测试发现在虚拟机上运行，可能不生成gmon.out。
> - 一定不能捕获、忽略SIGPROF信号。man手册对SIGPROF的解释是：profiling timer expired. 如果忽略这个信号，gprof的输出则是：Each sample counts as 0.01 seconds. no time accumulated。
> - 如果程序运行时间非常短，则gprof可能无效。因为受到启动、初始化、退出等函数运行时间的影响。
> - 程序忽略SIGPROF信号！



### perf *

命令行工具，有很多子功能，包含 函数调用 / 火焰图、内存申请记录（定位到函数）、内存泄漏检测 工具。

可以使用命令 生成 text、pdf（火焰图、函数调用关系图） 等形式的展示。



[系统性能分析工具--Perf - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/614212908) 基本使用，基本选项

[包罗万象-perf命令介绍 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/621893549) 各个命令介绍

生成的 perf.data 可以放到这个可视化网站上看 [speedscope](https://www.speedscope.app/)



perf 的一个可视化工具，也是一个 perf 的 UI 工具（推荐）：

KDAB 的 hotspot，linux（带图形界面的）平台运行 .appImage 文件，或者在如 ubuntu 平台安装 hotspot 软件即可用。具体参考官方文档。[KDAB/hotspot: The Linux perf GUI for performance analysis. (github.com)](https://github.com/KDAB/hotspot)。

> The main feature of Hotspot is the graphical visualization of a `perf.data` file.



### ASan / MSan / TSan / UBSan *

**ASan**

Address Sanitizer

官方文档 [AddressSanitizer · google/sanitizers Wiki (github.com)](https://github.com/google/sanitizers/wiki/AddressSanitizer)。



clang 官方文档 [AddressSanitizer — Clang 21.0.0git documentation (llvm.org)](https://clang.llvm.org/docs/AddressSanitizer.html)。



[C++ ASAN (Address Sanitizer) Introduction | hacking C++ (hackingcpp.com)](https://hackingcpp.com/cpp/tools/asan.html)。

> - detects memory corruption bugs
>   - memory leaks
>   - access to already freed memory
>   - access to incorrect stack areas
>   - ...
> - instruments your code with additional instructions
>   - roughly 70% runtime increase
>   - roughly 3-fold increase in memory usage

[内存检测工具 AddressSanitizer - 简书 (jianshu.com)](https://www.jianshu.com/p/d80db380e295)。

> AddressSanitizer 是一个内存检测工具。支持GCC 4.8 及以上。在编译时添加`-fsanitize=address`选项，如果为了得到更全面的信息可以用`-fno-omit-frame-pointer`。

> 该工具为gcc自带，4.8以上版本都可以使用，支持Linux、OS、Android等多种平台，不止可以检测内存泄漏，它其实是一个内存错误检测工具，可以检测的问题有：
>
> - 内存泄漏
> - 堆栈和全局内存越界访问
> - free后继续使用
> - 局部内存被外层使用
> - Initialization order bugs



更多详情：

- [内存错误检测工具-AddressSanitizer（ASAN）_asan安装-CSDN博客](https://blog.csdn.net/qq_15437629/article/details/114440930)。

  > Valgrind 其会极大的降低程序运行速度，大约降低10倍，而 AddressSanitizer 大约只降低2倍！

- [深入理解Asan：内存错误检测工具与实践-CSDN博客](https://blog.csdn.net/weixin_42136255/article/details/133815129)。

- [关于 ASAN - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/512578904)。

- [ASAN 问题总结-CSDN博客](https://blog.csdn.net/weixin_31260305/article/details/133288437)。

- [KASan介绍-CSDN博客](https://blog.csdn.net/weixin_42136255/article/details/133814026)。

- [C++(Qt)软件调试---GCC编译参数学习-程序检测（13）_gcc 编译-fsanitize=address-CSDN博客](https://blog.csdn.net/qq_43627907/article/details/132890999)。

  > AddressSanitizer（ASan）是一种用于检测和调试内存错误的工具。它是由Google开发的，并内置于GNU编译器套件（GCC）和LLVM编译器中。
  >
  > 释放后使用（野指针）
  >
  > 堆缓冲区溢出
  >
  > 栈缓冲区溢出
  >
  > 全局缓冲区溢出
  >
  > 返回局部堆区地址后使用（经过测试没检测出来）
  >
  > 作用域外使用栈内存
  >
  > 初始化顺序错误（经过测试未检测出来）
  >
  > 内存泄漏



使用：

首先说结论：对于 linux，则 gcc 和 clang 均可（注意版本）。对于 win，则 则 mingw-w64 没有带 ASAN 库，所以 win 上只能用 clang（而且还是特定的出包，比如 MSYS2 的 clang 包可以用 ASAN） 来使用 ASAN。



先碎碎念一波，各种查找信息和试验搞了半天，这里记录下：mingw 版本的 gcc 没有集成 ASAN 这个库，[c++ - MinGW-w64's gcc and Address Sanitizer - Stack Overflow](https://stackoverflow.com/questions/31144000/mingw-w64s-gcc-and-address-sanitizer)，并且 mingw 官网也说 win 上没有支持 ASAN [Contribute - MinGW-w64](https://www.mingw-w64.org/contribute/)。而 MSYS2 （使用其里面的 clang 工具链）是有的，如果你想使用 MSYS2 就可以配置环境直接用其工具链上手。要是非要用 mingw 环境，则要试着 自己编译 ASAN 库来使用，[自己动手编译asan库 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/71564723)，或者自己编 asan 源码 [AddressSanitizerHowToBuild · google/sanitizers Wiki (github.com)](https://github.com/google/sanitizers/wiki/AddressSanitizerHowToBuild)，自己编这个，这些我都暂没有在 win 上试成功，不推荐轻易尝试，MSYS2 和 Cygwin 等已经提供了比较好用的环境，自己编译的话用于研究和学习可以，但这个学习的路径比较陡峭所以不推荐轻易尝试，学习途径有很多（自己搭建开发环境，可以参考 TODO 放自己 cmake 模板工程 仓库），凡事讲究成本。

clang 在 win 上是支持 ASAN 的 [AddressSanitizerWindowsPort · google/sanitizers Wiki (github.com)](https://github.com/google/sanitizers/wiki/AddressSanitizerWindowsPort)。clang 官方也说 AddressSanitizer 支持 win 但是 支持不太好 [AddressSanitizer — Clang 20.0.0git documentation (llvm.org)](https://clang.llvm.org/docs/AddressSanitizer.html#more-information)。自己本地 win 上这种情况就可以换用 clang 编一编来跑一跑（编出来也是用于测试的，而非正式环境用），又发现，还需要依赖 compiler-rt 这个工具。这个 compiler-rt 可以用 MSYS2 安装。。折腾了一圈，还是拥抱 MSYS2 吧，用这个来管理所有编译相关工具链吧。。话又说回来，AddressSanitizer 在 win 上支持并不好，所以 win 上还是换用其它工具吧 比如 DrMemory（专用于 win 的），在 linux 下就可以愉快的使用 AddressSanitizer（gcc 和 clang 均可）。 

win 上使用 ASAN 路径：

- MSYS2 安装指引

  [MSYS2](https://www.msys2.org/)

  [MSYS2-Installation - MSYS2](https://www.msys2.org/wiki/MSYS2-installation/)

  - 关于几个环境的区别：[Environments - MSYS2](https://www.msys2.org/docs/environments/)，常用 UCRT64 和 CLANG64。
  - 使用命令 `pacman -Syuu` 更新最新库。
  - 使用 `pacman -Ss <package_name>` 来搜索包名称。所有包的搜索 [Pending Package Updates - MSYS2 Packages](https://packages.msys2.org/queue)。
  - 对于 win 上常用的 mingw-w64 的安装和使用：可以参考 [MSYS2](https://www.msys2.org/)。打开 MSYS 的 ucrt 环境的 cmd，使用命令 `pacman -S mingw-w64-ucrt-x86_64-gcc` 来安装，并把 `.\ucrt\bin` 目录添加到环境变量，之后可用 `gcc -v` 命令 试验下。
  - 以及安装常用的 cmake 和 make，与上面 gcc 同理：`pacman -S mingw-w64-ucrt-x86_64-cmake` 和 `pacman -S mingw-w64-ucrt-x86_64-make`。

- 在 MSYS2 里的 CLANG64 环境下，执行如下 来安装 clang 工具链，以及 compiler-rt 库。

  ```bash
  pacman -S mingw-w64-clang-x86_64-clang
  pacman -S mingw-w64-clang-x86_64-compiler-rt
  ```

  在 MSYS2 目录下 `.\clang64\bin` 目录下可以搜索 ASAN 找到相应的库（不容易啊终于找到个win上能用的）

  使用 clang/clang++ 就可以使用 ASAN 了（在mingw-w64 工具链的目录下就没有，是 MSYS2 也没有编译这个库）

- 把 MSYS2 目录下的 `.\clang64\bin` 目录添加到环境变量。



一个例子：使用 MSYS2 目录下的 `.\clang64\bin` 里面的 clang++ 来编译下面的程序例子，就有 ASAN 的检测和打印了。后续就可以方便的集成到 cmake 等工程里面，给自己工程定义个 DEBUG 模式，在该模式下使用选项 `-fsanitize=address -fsanitize=undefined -fno-omit-frame-pointer -g` 等。

```c++
#include <cstdint>
#include <iostream>

/*
    env: 对于 linux，则 gcc 和 clang 均可，gcc 的信息如下。对于 win，则 mingw-w64 没有带 ASAN 库，所以 win 上只能用 clang 来使用 ASAN
        gcc/g++ -v:
            Target: x86_64-linux-gnu
        gcc/g++ -- version:
            gxx (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0
    compile:
        clang++/g++ -fsanitize=address -fno-omit-frame-pointer -g -O1 ./main.cpp -o main.exe
    run:
        ./main.exe
*/

int main(int argc, char* argv[])
{
    (void)argc;
    (void)argv;

    std::cout << " --- begin" << std::endl;

    int32_t* int_ptr;
    int_ptr = new int32_t(0);
    delete int_ptr;

    // int_ptr = nullptr;

    *int_ptr = 10;

    // int32_t num = *int_ptr;
    // std::cout << " --- *int_ptr: " << *int_ptr << std::endl;

    std::cout << " --- end" << std::endl;
}
```



**MSan**

Memory Sanitizer

基本编译器选项 `-fsanitize=memory -fPIE -pie -fno-omit-frame-pointer -g`。

[MemorySanitizer · google/sanitizers Wiki (github.com)](https://github.com/google/sanitizers/wiki/MemorySanitizer)。

```c
#include <stdio.h>

int main(int argc, char** argv) {
  int* a = new int[10];
  a[5] = 0;
  if (a[argc])
    printf("xx\n");
  return 0;
}

// 运行
%clang -fsanitize=memory -fPIE -pie -fno-omit-frame-pointer -g -O2 umr.cc
% ./a.out
==6726==  WARNING: MemorySanitizer: UMR (uninitialized-memory-read)
    #0 0x7fd1c2944171 in main umr.cc:6
    #1 0x7fd1c1d4676c in __libc_start_main /build/buildd/eglibc-2.15/csu/libc-start.c:226
```



clang 的 官方文档 [MemorySanitizer — Clang 21.0.0git documentation (llvm.org)](https://clang.llvm.org/docs/MemorySanitizer.html)。

基本选项 `-fsanitize=memory -fno-omit-frame-pointer -g`。



**TSan**

Thread Sanitizer

> `-fsanitize=thread`：使用 ThreadSanitizer（TSan）工具，它可以检测多线程程序中的数据竞争和其他线程相关的错误。数据争用是并发系统中最常见和最难调试的错误类型之一。当两个线程同时访问同一变量并且至少有一个访问是写入时，就会发生数据争用。



[ThreadSanitizerCppManual · google/sanitizers Wiki (github.com)](https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual)。



clang 官方文档 [ThreadSanitizer — Clang 21.0.0git documentation (llvm.org)](https://clang.llvm.org/docs/ThreadSanitizer.html)。



**UBSan**

Undefined Behavior Sanitizer

[C++ UBSAN (Undefined Behavior Sanitizer) Introduction | hacking C++ (hackingcpp.com)](https://hackingcpp.com/cpp/tools/ubsan.html)。

> - detects many types of undefined behavior at runtime
>
>   - dereferencing null pointers
>   - reading from misaligned pointers
>   - integer overflow
>   - division by zero
>   - ...
>
> - instruments your code with additional instructions:
>
>   runtime increase in debug build~25%

> `-fsanitize=undefined`：使用 UndefinedBehaviorSanitizer（UBSan）工具，它可以检测代码中的未定义行为，如空指针解引用、数组越界、变量溢出、除0 等等。



clang 的 官方文档 [UndefinedBehaviorSanitizer — Clang 21.0.0git documentation (llvm.org)](https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html)。



### 专用于 win 的工具

这里会罗列各种可能的方法，很多本文作者并没有试过。正如 unix 一个设计哲学——"提供机制，而不是提供策略"（实际采用的策略是因场景、需求选取使用一些机制来组合使用）。



一个综合贴：[[QT编程系列-43\]: Windows + QT软件内存泄露的检测方法_qt 内存泄露排查手段-CSDN博客](https://blog.csdn.net/HiWangWenBing/article/details/133519665)。

> 2.1 内存监测工具 -Valgrind
> 2.2.1 Valgrind for Linux
> 2.2.2 Valgrind for Windows
>
> 2.2 内存监测工具-Dr. Memory
>
> 2.3 内存监测工具-Visual Leak Detector
>
> 2.4 内存监测工具-WinDbg
>
> 2.5 Windows进程内存监控工具——任务管理器
>
> 2.6 Windowx线程内存 监控工具——Windows性能工具集（Windows Performance Toolkit）——xperf 命令行工具
>
> 2.7 API函数获取线程级内存使用情况——Windows API中的GetProcessMemoryInfo函数
>
> 2.8 Windows性能监控——性能监视器



补充：

- Windows Sysinternals Suite



**DrMemory**

[Home (drmemory.org)](https://drmemory.org/)。下载后，drmemory 的 bin 目录添加环境变量，即可 shell 中运行 `drmemory -version`。

参考：

- [DynamoRIO/drmemory: Memory Debugger for Windows, Linux, Mac, and Android](https://github.com/DynamoRIO/drmemory)。
- [Running Dr. Memory (drmemory.org)](https://drmemory.org/page_running.html)。
- [Dr. Memory 使用 - 简书 (jianshu.com)](https://www.jianshu.com/p/183b0944a092)。



本地编译，使用 MinGW，用于 DrMemory

```bash
g++ .\main.cpp -g -static-libgcc -static-libstdc++ -ggdb -o main.exe
```

执行（但是没有一次正常过，试过各种选项）

```
drmemory.exe -- .\main.exe
```



**Visual Leak Detector**

内存泄漏检测（win 上）

[内存泄露检测工具VLD(Visual Leak Detector)使用说明-CSDN博客](https://blog.csdn.net/devillixin/article/details/126196206)

[Qt / MSVC 中使用内存泄露检测工具 VLD(Visual Leak Detector)_qt内存泄漏检测工具-CSDN博客](https://blog.csdn.net/weixin_41863029/article/details/128482295)



**WinDbg**



**Application Verifier**

配置太复杂了..若长期专门开发 win 程序可以用



**Windows Performance Toolkit**



**Windows Sysinternals Suite**

[Sysinternals Suite - Sysinternals | Microsoft Learn](https://learn.microsoft.com/zh-cn/sysinternals/downloads/sysinternals-suite)。

[微软工具包Windows Sysinternals Suite简介-CSDN博客](https://blog.csdn.net/nodeman/article/details/109615209)。

[Sysinternals Suite免费的Windows系统工具集（系统管理良兵利器） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/569262316)。



**Windows API**

Windows API 中的 GetProcessMemoryInfo 函数



### 自实现内存泄露检测工具原理

对 malloc / free 或 new / delete 做 插桩函数 或者 对其重载 来实现。

源自 [C++不用工具，如何检测内存泄漏？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/29859828/answer/1798470821)。



## 静态检查 *

使用静态代码分析工具，来检测潜在的内存泄漏、不安全的内存操作，以及其它不合规范 等问题。这些工具可以帮助你发现代码中的潜在问题，提升程序健壮性，也可针对性减少内存占用。



### cppcheck *



官网 [Cppcheck - A tool for static C/C++ code analysis](http://cppcheck.net/)。



安装 bin 到系统并添加到环境变量后，VsCode 安装 `cpp-check-lint` 插件即可，可以对插件做进一步配置。

VsCode 的 cppcheck 插件使用，但也只是 单个文件的扫描，而且也不需要写的时候试试检查，一般是 对整个工程 最 周期性扫描。

[vscode中嵌入cppcheck进行静态检查，包含插件使用方法_cppcheck集成到vscode-CSDN博客](https://blog.csdn.net/qq_35333978/article/details/122347687)。设置插件，也可以通过 VsCode 可视化操作而不必直接修改 setting 的 json 文件。这个因人习惯而异吧。



cppcheck 更多功能的插件 [cppcheck/addons/README.md at main · danmar/cppcheck (github.com)](https://github.com/danmar/cppcheck/blob/main/addons/README.md)

这些插件，在安装 win 版本 cppcheck 时候，可以全部勾选上，就带着了，可以 GUI 使用，安装时候 选择所有。



Jenkins cppcheck plugin

[jenkinsci/cppcheck-plugin: Jenkins cppcheck plugin (github.com)](https://github.com/jenkinsci/cppcheck-plugin)



### clangd / clang-tidy

clangd

clangd 提供的 LSP 服务 给 VsCode 日常开发的 跳转、补全 等用，见 `cmake 模板工程` 仓库（暂没有上）的具体使用。



clang-tidy

> `clang-tidy`拥有多种内置检查器，可用于检测性能问题、代码规范、可能的程序错误、可移植性问题等。此外，它允许用户自定义规则，可以非常灵活地适应不同的编程规范和需求。

[Clang-Tidy — Extra Clang Tools documentation (llvm.org)](https://clang.llvm.org/extra/clang-tidy/index.html) 其中包含了 Clang Static Analyzer，以及更多检查项。

[clang-tidy - Clang-Tidy Checks — Extra Clang Tools 20.0.0git documentation (llvm.org)](https://clang.llvm.org/extra/clang-tidy/checks/list.html) 支持的检查类型。

> clang-tidy 大致分类：
> boost 检测boost库API使用问题
> cert 检测CERT的代码规范
> cpp-core-guidelines 检测是否违反cpp-core-guidelines
> google 检测是否违反google code style
> llvm 检测是否违反llvm code style
> readability 检测代码上相关问题，但又不明确属于任何代码规范的
> misc 其它一些零碎的check
> mpi 检测MPI API问题
> modernize 把C++03代码转换成C++11代码，使用C++11新特性
> performance 检测performance相关问题

clang-tidy 检查项各项更详细的说明：[使用 Clang-Tidy 进行静态代码分析：完整的配置与 CMake 集成实例_clang-tidy cmake-CSDN博客](https://blog.csdn.net/stallion5632/article/details/139545885)



[开源C++静态代码检测工具clang-tidy、cppcheck和oclint的比较_clang-tidy cppcheck-CSDN博客](https://blog.csdn.net/stallion5632/article/details/139569439)。



这是 clang-tidy 介绍 和 命令行的使用，一般更好的使用方法是与 IDE 结合，比如 VsCode。

[30.静态代码分析工具clang-tidy-CSDN博客](https://blog.csdn.net/lx_ros/article/details/139104753)。[c++静态代码扫描工具clang-tidy详细介绍-CSDN博客](https://blog.csdn.net/sexyluna/article/details/132001613)。



[vscode配置clang-tidy插件_vscode clang-tidy-CSDN博客](https://blog.csdn.net/weixin_45978181/article/details/128239547)。



实测发现，clang-tidy 有一些基础的问题查不出来，比如数组越界，等等（或许也是我配置有问题？）。这种意义上，cppcheck 还是 好用些。



关于 clangd、clang-tidy 的配置文件，可参考 TODO 放自己 cmake 模板工程 仓库。



scan-build

> `scan-build`是一个命令行工具，用于在编译时调用`Clang`静态分析器来分析C/C++代码。它的主要用途是识别程序中可能导致bug的构造。
>
> `scan-build`在编译过程中拦截编译器的调用，插入静态分析过程。它会生成一份包含潜在错误和警告的报告，并可以通过生成的HTML报告详细查看问题所在及上下文。
>
> `scan-build`通常在命令行环境中使用，可以轻松地与持续集成系统集成，作为项目构建过程的一部分自动运行。



### 编译选项的警告提示



综合 [C++ Diagnostic Basics: Warnings, Assertions, Testing | hacking C++ (hackingcpp.com)](https://hackingcpp.com/cpp/diagnostics.html)。

使用 `-Wall`、`-Wextra` 等标志打开所有警告。



```bash
-Wall,
-Wextra,
-pedantic,
-Wpedantic
```



## 大型静态检查软件



### SonarQube + sonar-cxx *

社区开源的。可以和 jenkins 结合。



[SonarQube C++ 社区插件安装与配置指南-CSDN博客](https://blog.csdn.net/gitblog_09137/article/details/142229356)。

[SonarQube 安装及使用 | Server 运维论坛 (learnku.com)](https://learnku.com/articles/59179)。



### Black Duck / Coverity

商业级静态扫描服务，收费的。

- [SAST - 静态代码分析工具 | Black Duck](https://www.blackduck.com/zh-cn/static-analysis-tools-sast.html)。[Coverity 静态分析软件 | Black Duck](https://www.blackduck.com/zh-cn/static-analysis-tools-sast/coverity.html)。
- [Black Duck 软件组件分析 (SCA) | Black Duck](https://www.blackduck.com/zh-cn/software-composition-analysis-tools/black-duck-sca.html)。帮助团队管理在应用和容器中使用开源和第三方代码所带来的安全、质量和许可证合规性风险。



[Coverity 代码静态安全扫描工具 ： 认识Coverity-CSDN博客](https://blog.csdn.net/baidu_31295661/article/details/122367838)。



# 内存占用优化相关



## 初步检查

如果对程序熟悉，针对性的对占内存的地方 进行优化。



使用 上述 内存统计命令和工具，检查。

看大头：

- 最小工程放到机器上看内存占用，和正式的进程进行比较

  一般 [heap]、[anon]、各种库、字体等 占了该进程的主要内存大头

- 程序中按各块功能逐个开启，看内存。

- UI界面，逐个页面加载看内存增长变化。

看细节：

比如 perf mem 等工具分析每个函数申请内存的情况，找出大头。



## 基本优化

这里以 qt 程序的内存占用优化为例。



### 库编译精简



编译器选项：使用适当的编译器选项，例如优化标志，以提高生成的代码的效率和内存使用。

调试相关的有 `-g -ggdb`，优化相关的有 `-O0 -O1 -O2 -Os`，工程上经验建议最高允许也常常开到 `-O2`。



比如 qt库 有一些精简编译的选项可以用。

在 buildroot 的 qt 选项里面 添加 Custom configuration options，看 package 里面 qt 文件夹 里面的 .in 和 .mk 文件可见，最终传递给 
`buildroot/output/<board>/build/qt5base-5.xx.x` 下面的 configure（通过 `./configure -help` 查看 所有配置选项）

添加选项 `-optimize-size -release -strip -reduce-exports`。

主要的核心库

- libQt5Core.so.5.12.2    4.89MB
- libQt5Gui.so.5.12.2    3.71MB
- libQt5Widgets.so.5.12.2    5.64MB
- libQt5Qml.so.5.12.2
- libQt5Quick.so.5.12.2    5.64MB
- libQt5Network.so.5.12.2    1.46MB
- libQt5VirtualKeyboard.so.5.12.2

qt 库 重编（这里是基于 buildroot 编译框架 来 编译 qt package）

```bash
make qt5base-dirclean && make qt5base-configure && make qt5base
```



### 针对项

- 程序的内存优化。

- UI 页面不缓存（但是 UI 理论上相对会变卡顿，具体看芯片性能）。精简 UI 页面。限制显示元素。

- 图片尽量不变形，图片变形会拷贝图片导致内存暴增（Qt）。批量显示图片的地方可以设置图片不缓存。

- 字体。

  这里是针对性缩减字体文件的，如果 flash 或者 ram 充裕 则不推荐这么做，为了未来的可能出现的各种文本的正常显示，留一定较广泛的兼容性较好。

  使用 fontcreator 挑出所用文字，缩小字体库，需要手动增减文字，对于后面增加文案来说不友好 https://blog.csdn.net/xiaohui_brook/article/details/51909612；一个提取给出文本中所有单独文字工具 https://gitee.com/Polarix/MinimumFontLib。



## chatGPT 给出 内存优化 基本经验

以下 chatGPT 给出。



Qt是一个流行的C++应用程序开发框架，可以用于创建跨平台的图形用户界面应用程序。要降低Qt应用程序的内存使用，可以考虑以下方法：

1.使用动态分配内存：避免在堆栈上创建大型对象，而是使用堆上的动态内存分配。使用new和delete或者更好的智能指针来管理对象的生命周期。
2.资源管理：确保及时释放不再需要的资源，如图像、字体、音频等。Qt提供了QResource类来管理应用程序的资源，确保在不需要时卸载它们。
3.使用精简的数据结构：选择最适合你的数据的数据结构。有时候，使用QVector比QList更高效，或者使用QHash而不是QMap，具体取决于你的需求。
4.避免不必要的复制：使用const引用来传递参数，以避免复制大型对象。使用move语义来移动对象，而不是复制它们。
5.使用局部变量：在可能的情况下，使用局部变量而不是全局变量或类成员变量。局部变量在超出其作用域后会自动释放内存。
6.定期清理内存：如果你的应用程序长时间运行，确保定期清理不再使用的内存。Qt的内存管理通常是自动的，但你可以显式地调用QCoreApplication::sendPostedEvents()来处理未处理的事件，这可以释放不再需要的内存。
7.使用Qt的容器类：Qt提供了一系列高效的容器类，如QList、QVector和QMap。使用这些容器类可以减少内存分配和释放的开销。
8.避免内存泄漏：定期检查应用程序以确保没有内存泄漏。你可以使用工具如Valgrind或Qt的内存分析工具来检测内存泄漏。
9.优化图形资源：如果你的应用程序涉及大量图形资源，确保这些资源被合理地加载和释放。使用Qt的图像和绘图类，如QImage和QPainter，来管理图形资源。
10.使用虚函数：如果你使用Qt中的继承体系，请合理使用虚函数。这可以减少对象的内存占用，并允许更高效的动态多态性。
11.精简Qt模块：如果你只需要Qt的特定功能，可以考虑只包含所需的模块，而不是整个Qt框架。这可以减小应用程序的二进制文件大小和内存占用。
12.使用Qt的资源系统：Qt的资源系统允许你将资源文件嵌入到二进制文件中，而不是在磁盘上存储它们，从而减少内存占用。

要降低Qt应用程序的内存使用，最重要的是了解你的应用程序的需求，以便选择合适的数据结构和内存管理策略，并进行适当的优化。

------



如果你的Qt程序已经开发完成，但你仍然想优化内存使用并减少不必要的模块占用内存，可以考虑以下方法：

1.静态分析工具：使用静态代码分析工具，如Clang Static Analyzer或Cppcheck，来检测潜在的内存泄漏、不安全的内存操作和其他潜在问题。这些工具可以帮助你发现代码中的潜在问题，从而减少内存占用。
2.动态分析工具：使用动态分析工具，如Valgrind（在Linux中）或Application Verifier（在Windows中），来检测运行时的内存错误和泄漏。这些工具可以帮助你找出程序中的内存问题，以便进行修复。
3.使用更轻量的替代品：如果你发现Qt模块占用了大量内存，考虑是否可以用更轻量的替代品替代它们。有时候，自定义的轻量级库可能比Qt更适合特定的任务，从而减少内存占用。
4.延迟加载模块：如果你的应用程序使用了多个Qt模块，但不是所有模块都在启动时立即需要，可以考虑延迟加载这些模块。这意味着只有在需要时才加载它们，而不是一开始就加载所有模块。
5.优化资源加载：如果你的应用程序使用大量图像、字体或其他资源，确保资源加载是延迟的，只在需要时加载，然后在不再需要时及时释放。
6.使用轻量级控件：如果你使用Qt的GUI模块，考虑使用轻量级的控件替代重型的控件。例如，可以使用QLabel替代QWebView来显示简单的HTML内容。
7.精简依赖项：如果你使用了第三方库或模块，确保只包括你实际需要的部分，避免引入不必要的依赖项。
8.内存池：实现自定义的内存池，以便更有效地分配和管理内存。这可以减少内存碎片和提高内存使用效率。
9.代码优化：审查代码并寻找可以优化的部分，例如减少不必要的对象复制、避免过度使用虚函数等。优化代码可能需要对性能和内存占用进行权衡。
10.使用Qt的资源系统：将应用程序中的资源文件合并到Qt的资源系统中，以减少磁盘上的文件访问，并降低内存占用。
11.动态链接：如果你的应用程序使用了大量的Qt模块，可以考虑将Qt库动态链接，以减小可执行文件的大小，因为它不会包含Qt库的副本。
12.编译器选项：使用适当的编译器选项，例如优化标志，以提高生成的代码的效率和内存使用。

在进行这些优化时，确保进行充分的测试，以确保你没有引入新的问题或破坏了应用程序的功能。内存优化通常需要权衡性能和内存使用，因此需要根据具体情况仔细评估每个优化步骤的效果。





# 查看 bin 结构 / size 优化相关

## size 解析

```bash
$ size ./mainProj
   text    data     bss     dec     hex filename
  49820     208    3376   53404    d09c ./mainProj
```



## elf 解析

**查看各段**

```bash
# 使用 readelf -S <bin> 查看段
# 使用 readelf -h 来查看用法
readelf -S <bin>

# 也可以使用 objdump -x <bin>，注意要使用 bin 对应的编译器的 objdump
objdump -x <bin>

# 把段的原始二进制内容拷出来
objcopy --only-section=.rodata <bin> <output_file>

# 使用 strings 查看 <output_file> 里面的字符串成分
strings <output_file> > <output_strings_file>
```



[objdump命令的常见用法-CSDN博客](https://blog.csdn.net/u014100559/article/details/140620616)。

[基于GCC的工具objdump实现反汇编-CSDN博客](https://blog.csdn.net/qq_27071221/article/details/134297683)。



**查看对象和函数**

查看程序内各个对象和函数的大小并排序

```bash
readelf -s -W <bin> > symbols.txt
awk 'NR > 5 {print $3, $4, $8}' symbols.txt | sort -nr > temp1.txt

第一行的输出例子：

Symbol table '.dynsym' contains 1917 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND __aeabi_unwind_cpp_pr1@GCC_3.5 (3)
     2: 00000000     0 TLS     GLOBAL DEFAULT  UND _ZSt15__once_callable
     3: 00000000     0 OBJECT  GLOBAL DEFAULT  UND _ZTISt12system_error
     4: 00000000     0 NOTYPE  WEAK   DEFAULT  UND _ZTHN6BGuiFe13ThreadPoolE

把第一行的输出喂给 AI工具来生成，指引其对这段输出进行排序，生成上面第二段命令，执行则排序并输出到 temp1.txt 文件里面
```



## size 优化的点备忘

针对一些占 size 大头 的 东西

- 图片：使用优化工具，减 size；并且尽量使用 编码的数据，如直接存储文件，而不要存储图片数据数组（会膨胀很多，至少 5 倍以上）；可以的话还可以压缩处理。

  以及其它素材文件。

- 库：编译的时候可以去掉一些选项，不编译一些组件，缩减库。

- 依照上面 readelf 读出的程序内各个对象和函数的大小，再针对大的项，进行缩减。

- 加 根据不同产品区分的 功能宏，不编译 不必要的部分。



- [程序体积优化指南：十个实用技巧 | 性能优化 | C++ 编程指南 (chengxumiaodaren.com)](https://chengxumiaodaren.com/docs/performance/size-opt/)。

  > 大体思路有这些：
  >
  > - 好好写代码，**减小代码段体积**，别人300代码的逻辑我们50行搞定，程序体积肯定有机会更小一些，这个就得考验开发者自己的编程功底了
  > - 如果是C++程序，可以尽量减少模板的使用，**模板实例化可能会导致代码膨胀**
  > - 不用引用没有用的头文件
  > - **使用strip**（gcc 工具链的一个工具），像脱衣服一样，移除程序的所有符号，这也是很多开发者常用的方式
  > - strip只会清除普通符号，不会动态符号表中的符号，某些动态符号其实也可以隐藏掉，进而来减小库的体积，可以使用-fvisibility=hidden命令
  > - **巧用.bss段**，未初始化的全局变量和局部静态变量会存在.bss段中，这些变量不占用程序空间
  > - inline-limit：**内联过多会导致代码段体积较大**，可以通过此优化选项减少内联的数量
  > - 开启Os编译，这是产生较小代码体积的优化选项（但工程上建议最多用到 -O2）
  > - 适当使用编译选项-fdata-sections和-ffunction-sections（对于没用到的函数则将他们抛弃，会减慢编译和链接过程）
  > - **考虑链接动态库而非静态库**

  

# 包发布



[phusion/holy-build-box: System for building cross-distribution Linux binaries](https://github.com/phusion/holy-build-box)。